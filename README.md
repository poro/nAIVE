# nAIVE

**The AI-native game engine.** Create worlds with YAML, Lua, and natural language.

Built from the ground up in Rust. Worlds are created by AI, rendering happens on your GPU, and everything — scenes, materials, shaders, game logic — is a human-readable file that AI can generate, inspect, and modify.

---

## Why nAIVE

| Traditional Engine | nAIVE |
|---|---|
| Games are compiled binaries | Worlds are YAML + Lua, generated by AI |
| Authoring requires a visual editor | The AI agent _is_ the editor |
| Shaders are HLSL/GLSL, platform-locked | SLANG shaders cross-compile to any GPU backend |
| 3D assets from art pipelines only | Gaussian splats from text prompts |
| Render pipeline hardcoded in C++ | YAML-defined render pipeline DAG |
| Entity counts limited by CPU | GPU compute simulation drives 50,000+ entities |

**Sub-second hot-reload.** Shaders in <200ms. Scenes in <100ms. Scripts in <50ms. 100x faster than Unity or Unreal.

**No royalties. No restrictions.** The engine is MIT licensed. Build anything. Ship it. Sell it. Keep everything.

---

## Install

### Homebrew (macOS)

```bash
brew install poro/tap/naive
```

### From source

```bash
git clone https://github.com/poro/nAIVE.git
cd nAIVE

# Download SLANG SDK (required for shader compilation)
# macOS ARM:
curl -L https://github.com/shader-slang/slang/releases/download/v2026.2.1/slang-2026.2.1-macos-aarch64.tar.gz | tar xz -C vendor/
# macOS Intel:
curl -L https://github.com/shader-slang/slang/releases/download/v2026.2.1/slang-2026.2.1-macos-x86_64.tar.gz | tar xz -C vendor/

export SLANG_DIR=$(pwd)/vendor
cargo build --release
```

The build produces three binaries in `target/release/`:
- **`naive`** — Main CLI for running games
- **`naive-runtime`** — Full engine runtime (same as `naive`)
- **`naive_mcp`** — MCP JSON-RPC server for AI agent integration

### Requirements

- Rust 1.75+ (for building from source)
- macOS 12+ (Metal), Windows 10+ (Vulkan/DX12), or Linux (Vulkan)
- GPU with WebGPU support

---

## Quick Start

```bash
# Create a new project
naive init my-game
cd my-game

# Run the default scene
naive run

# Run a specific demo scene
naive run --scene scenes/genesis.yaml

# Run tests
naive test
```

### Project structure

```
my-game/
├── naive.yaml               # Project config
├── CLAUDE.md                # AI agent instructions (Lua API reference)
├── scenes/                  # YAML scene definitions
├── logic/                   # Lua game scripts
├── assets/
│   ├── meshes/              # .gltf, .glb, .ply (Gaussian splats)
│   ├── materials/           # YAML PBR material definitions
│   ├── textures/            # PNG, JPG, HDR
│   └── audio/               # OGG, WAV
├── shaders/passes/          # SLANG render pass shaders
├── pipelines/               # YAML render pipeline DAG
├── input/bindings.yaml      # Input action mappings
├── events/schema.yaml       # Event type definitions
└── tests/                   # Automated Lua test scripts
```

---

## Features

### Rendering
- Deferred PBR pipeline (shadow, G-buffer, lighting, bloom, tonemap, FXAA)
- Native Gaussian splatting with depth compositing
- Shadow mapping with PCF filtering
- HDR + bloom + ACES tonemapping
- SLANG shaders that cross-compile to WGSL for all GPU backends
- YAML-defined render pipeline DAG — add passes without recompiling

### Physics & Gameplay
- Rapier 3D physics — rigid bodies, colliders, character controllers
- Health/damage system with `on_damage`/`on_death` callbacks
- Hitscan raycast API with entity hit detection
- Physics-driven projectiles with auto-damage
- Collision damage component
- Third-person camera with wall collision

### Scripting
- Lua 5.4 with per-entity sandboxing
- 40+ API functions (transform, physics, audio, UI, events, input)
- Hot-reload with state migration via `on_reload()`
- Lifecycle hooks: `init()`, `update(dt)`, `on_collision()`, `on_damage()`, `on_death()`

### Production Systems (Tier 2)
- Dynamic GPU instance buffer — no more 256-entity ceiling
- Safe entity lifecycle — destroy-before-spawn ordering
- Runtime entity queries by tag — `scene.find_by_tag()`, `entity.has_tag()`
- Event subscription from Lua — `events.on("name", callback)`
- Built-in entity pooling — `entity.pool_acquire()` / `entity.pool_release()`
- CPU particle simulation (GPU billboard rendering TBD)

### Infrastructure
- MCP command socket for AI agent control
- Headless test runner for automated playtesting
- Event bus with YAML schema validation
- Spatial audio (Kira)
- File watching with hot-reload for scenes, scripts, shaders, materials

---

## Architecture

```
naive-core        (MIT)    Shared types, ECS components, scene format, event bus
    │
naive-client      (MIT)    Full engine: renderer, physics, audio, scripting
    │
naive-runtime     (MIT)    Thin CLI binary
    │
naive-server      (BSL)    Multiplayer hosting, matchmaking, AI Director (optional)
```

### Tech stack

| Layer | Technology |
|-------|-----------|
| Language | Rust |
| Rendering | wgpu 24 (Metal / Vulkan / DX12 / WebGPU) |
| Shaders | NVIDIA SLANG → WGSL cross-compilation |
| ECS | hecs |
| Physics | Rapier3D 0.22 |
| Scripting | Lua 5.4 (mlua, vendored) |
| Audio | Kira 0.9 |
| Asset formats | glTF, PLY (Gaussian splats), YAML (scenes, materials, pipelines) |

---

## Demo Scenes

Run any scene with `naive run --scene scenes/<name>.yaml`:

| Scene | Description |
|-------|------------|
| `genesis.yaml` | Full showcase — 65 entities, 24 lights, 5K splats, cinematic camera |
| `pbr_gallery.yaml` | Metallic/roughness material grid |
| `neon_dreamscape.yaml` | Emissive materials with pulsing animations |
| `physics_test.yaml` | Rigid body physics, collisions, gravity |
| `combat_demo.yaml` | Health/damage, hitscan, projectiles |
| `third_person_demo.yaml` | Third-person camera orbit with wall collision |
| `splat_test.yaml` | Gaussian splatting rendering |
| `cosmic_splats.yaml` | Splats with cinematic camera orbit |
| `inferno.yaml` | Fire-themed PBR showcase |
| `void.yaml` | Dark ambient showcase |
| `titan.yaml` | Large-scale scene with dramatic camera |
| `ui_demo.yaml` | UI overlay system demo |
| `audio_test.yaml` | Spatial 3D audio |
| `tier2_stress_test.yaml` | 300+ entities — dynamic GPU buffer growth |
| `tier2_lifecycle_demo.yaml` | Entity lifecycle, pooling, tag queries |
| `tier2_particle_demo.yaml` | Particle emitters with orbiting camera |

---

## Lua API

Every entity can have a Lua script attached. Scripts run in a per-entity sandbox with access to the full engine API.

```lua
function init()
    self.speed = 5
    self.health = 100
end

function update(dt)
    -- Move forward
    local x, y, z = entity.get_position(_entity_string_id)
    entity.set_position(_entity_string_id, x, y, z - self.speed * dt)

    -- Hitscan raycast
    local hit, id, dist = physics.hitscan(x, y, z, 0, 0, -1, 50)
    if hit then
        entity.damage(id, 25)
    end

    -- HUD
    ui.text(20, 20, "Health: " .. self.health, 18, 1, 1, 1, 1)
end

function on_damage(amount, source)
    self.health = self.health - amount
    ui.flash(1, 0, 0, 0.3, 0.2)  -- red flash
end

function on_death()
    audio.play_sfx(_entity_string_id, "assets/audio/explode.wav", 1.0)
    events.emit("enemy.killed", { id = _entity_string_id })
end
```

### Key API functions

```lua
-- Transform
entity.get_position(id)              --> x, y, z
entity.set_position(id, x, y, z)
entity.set_rotation(id, pitch, yaw, roll)

-- Combat
entity.get_health(id)                --> current, max
entity.damage(id, amount)
entity.heal(id, amount)
physics.hitscan(ox,oy,oz, dx,dy,dz, range)  --> hit, id, dist, px,py,pz, nx,ny,nz
entity.spawn_projectile(owner, mesh, mat, pos, dir, speed, dmg, lifetime, gravity)

-- Queries (Tier 2)
scene.find_by_tag(tag)               --> { id1, id2, ... }
entity.has_tag(id, tag)              --> bool
entity.add_tag(id, tag)
entity.remove_tag(id, tag)

-- Events (Tier 2)
events.emit("event.name", { data })
events.on("event.name", function(e) ... end)

-- Pooling (Tier 2)
entity.pool_acquire(name)            --> id or nil
entity.pool_release(id)

-- Materials
entity.set_base_color(id, r, g, b)
entity.set_emission(id, r, g, b)
entity.set_roughness(id, value)

-- UI
ui.text(x, y, text, size, r, g, b, a)
ui.rect(x, y, w, h, r, g, b, a)
ui.flash(r, g, b, a, duration)

-- Audio
audio.play_sfx(id, path, volume)
audio.play_music(path, volume, fade_in)

-- Input
input.pressed(action)                --> bool
input.just_pressed(action)           --> bool
```

---

## Scene Format

Scenes are YAML files that define entities with components:

```yaml
name: "My Scene"
settings:
  ambient_light: [0.2, 0.2, 0.3]
  gravity: [0, -9.81, 0]

entities:
  - id: player
    tags: [player, team_a]
    components:
      transform:
        position: [0, 1, 0]
      mesh_renderer:
        mesh: assets/meshes/character.gltf
        material: assets/materials/hero.yaml
      character_controller:
        height: 1.8
        radius: 0.3
      health:
        max: 100
      script:
        source: logic/player.lua

  - id: enemy_goblin
    tags: [enemy, goblin]
    components:
      transform:
        position: [10, 1, 5]
      mesh_renderer:
        mesh: procedural:sphere
        material: assets/materials/enemy_red.yaml
      collider:
        shape: sphere
        radius: 0.5
      health:
        max: 30
      collision_damage:
        damage: 10
        destroy_on_hit: true
      script:
        source: logic/goblin_ai.lua
```

---

## Roadmap

Development follows a tiered system, each tier validated by proof-of-concept games:

| Tier | Systems | Status |
|------|---------|--------|
| **1** | Health, hitscan, projectiles, collision damage, third-person camera | **Done** (v0.1.2) |
| **2** | Dynamic GPU buffer, entity pooling, particles, tag queries, events | **Done** (v0.1.3) |
| **3** | GPU compute entity simulation (50,000+ entities at 60 FPS) | Planned |
| **4** | Vertex animation textures, skeletal animation, state machines | Planned |
| **5** | Vehicles, mounted weapons, inventory, loadout system | Planned |

**Proof game: HAVOC** — A 3D Vampire Survivors-style horde survival game. If nAIVE can render 50,000 physics-driven goblins while you drive a truck through them, it can handle anything.

See the full roadmap in [docs/nAIVE_Engine_PRD_v5.0.md](docs/nAIVE_Engine_PRD_v5.0.md).

---

## Documentation

| Document | Description |
|----------|------------|
| [Engine PRD v5.0](docs/nAIVE_Engine_PRD_v5.0.md) | Full engine specification and tiered roadmap |
| [Platform PRD v5.0](docs/nAIVE_Platform_PRD_v5.0.md) | Server infrastructure: multiplayer, matchmaking, AI Director |
| [Game Development Guide](docs/GAME_DEVELOPMENT_GUIDE.md) | How to build games with nAIVE |
| [Dev Log](docs/DEVLOG.md) | Development history and decisions |
| [HAVOC Dev Log](docs/havoc.dev.log) | Building a Vampire Survivors prototype in nAIVE |
| [Whitepaper](docs/whitepaper.md) | Technical whitepaper and benchmarks |

### PRD version history

| Version | Date | Key additions |
|---------|------|--------------|
| v1.0 | Dec 2025 | Initial spec — Rust + wgpu + SLANG vision |
| v2.0 | Jan 2026 | ECS, physics, scripting, Gaussian splatting |
| v3.0 | Jan 2026 | Deferred pipeline, PBR materials, audio |
| v4.0 | Feb 2026 | Unified platform (engine + server), four-word addressing |
| v5.0 | Feb 2026 | Tier system, gameplay primitives, HAVOC proof game |

---

## License

nAIVE uses a dual-license model:

### Engine (MIT)

The engine crates — **`naive-core`**, **`naive-client`**, and **`naive-runtime`** — are MIT licensed. You can use them for any purpose: personal, commercial, educational. Modify them, sell games built with them, fork them, include them in proprietary software. No royalties, no revenue sharing, no restrictions.

These three crates produce a complete game engine. You do not need the platform to build and ship games.

### Platform (BSL 1.1)

The server crate — **`naive-server`** — is licensed under the [Business Source License 1.1](LICENSE-BSL-1.1).

**What's allowed:**
- Building and selling games (no restrictions)
- Self-hosting game servers
- Using the platform for internal development
- Any non-competing use

**What's restricted:**
- Offering managed game-hosting or game-server orchestration as a commercial service to third parties

**The BSL converts to MIT on February 14, 2029.** After that date, the server code becomes fully open source under the same MIT license as the engine.

```
naive-core       MIT          Use for anything. No restrictions.
naive-client     MIT          Use for anything. No restrictions.
naive-runtime    MIT          Use for anything. No restrictions.
naive-server     BSL 1.1      No competing hosting services. Converts to MIT in 2029.
```

---

## Contributing

nAIVE is built with [Claude Code](https://claude.com/claude-code) as the primary development interface. The CLAUDE.md file in the project root contains the full Lua API reference and engine conventions for AI-assisted development.

```bash
# Run tests
cargo test

# Run with a specific scene
cargo run --bin naive -- --scene scenes/genesis.yaml

# Check compilation
cargo check --workspace
```

---

**Current version:** 0.1.3
