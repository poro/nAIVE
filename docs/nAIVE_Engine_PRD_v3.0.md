# nAIVE Engine PRD v3.0 — AI-Powered Networked Worlds

**Version:** 3.0
**Date:** February 2026
**Author:** Mark Ollila
**Status:** Draft

---

## 1. Executive Summary

nAIVE is an AI-native game engine where worlds are created by AI, rendered locally, controlled from anywhere, and shared with a four-word address.

The v1.0 foundation (16 phases, 16 demos) proved the core stack: Rust + wgpu + SLANG + hecs ECS + Lua scripting + YAML scenes + Rapier physics + Kira audio + Gaussian splatting + deferred PBR rendering + FXAA + shadow mapping + immediate-mode UI + MCP server + Telegram bot bridge.

v2.0 defined the intelligence layer: LLM-powered NPCs, natural language scene compilation, AI Director, generative Gaussian splatting, neural shaders, and multi-agent collaborative development.

**v3.0 unifies everything into a platform.** A world is created with natural language, published to a server under a memorable four-word name, and played by anyone who knows the address. AI agents live inside the world as NPCs, directors, and co-creators. Telegram commands reshape the world in real-time. The browser becomes the default client via WebGPU.

The thesis: **the most interesting games of the next decade will not be authored — they will be grown, evolved, inhabited, and co-created by humans and AI working together in shared persistent worlds.**

---

## 2. Vision

```
"make it rain in black.squirrel.white.deer"
```

A message sent from Telegram. Within 200ms, every player connected to that world sees rain particles falling, hears rain audio, and watches puddles form on the ground. The AI parsed "make it rain" into a weather system call. The server executed it in the world's Lua environment. State deltas flowed to all connected clients. The world changed because someone asked it to.

This is nAIVE v3.0.

### What Makes This Different

| Traditional Engine | nAIVE v3.0 |
|---|---|
| Games are compiled binaries | Worlds are YAML + Lua, generated by AI |
| Distribution via app stores | Share a 4-word address: `snake.3d.nokia.mark` |
| Authoring requires programming | Describe what you want in natural language |
| Static content after shipping | AI Director evolves the world while players play |
| NPCs follow scripts | NPCs are LLM agents with memory and personality |
| Single-player or dedicated servers | Any world is multiplayer by default (server authority) |
| Control via gamepad/keyboard only | Also controllable via Telegram, CLI, MCP, browser |

---

## 3. Architecture

### 3.1 Three-Layer Stack

```
                    ┌─────────────────────────────────────┐
                    │          CREATOR LAYER               │
                    │                                      │
                    │  Claude Code ──> YAML + Lua + Assets │
                    │  NL Compiler ──> Scene Generation     │
                    │  Telegram ────> Live World Commands   │
                    │  MCP Server ──> Agent Interaction     │
                    └──────────────┬──────────────────────┘
                                   │ publish / command
                    ┌──────────────▼──────────────────────┐
                    │          SERVER LAYER                 │
                    │                                      │
                    │  World Registry (4-word names)       │
                    │  Per-World:                          │
                    │    ├── hecs ECS (canonical state)    │
                    │    ├── Rapier Physics (headless)     │
                    │    ├── mlua Scripting (game logic)   │
                    │    ├── AI Agents (LLM NPCs)         │
                    │    ├── AI Director (adaptive)        │
                    │    └── State Broadcaster (deltas)    │
                    │  WebSocket Server                    │
                    │  Telegram Bridge                     │
                    │  Asset CDN                           │
                    └──────────────┬──────────────────────┘
                                   │ state deltas (WebSocket)
                    ┌──────────────▼──────────────────────┐
                    │          CLIENT LAYER                 │
                    │                                      │
                    │  wgpu Renderer (local GPU)           │
                    │  Kira Audio (local speakers)         │
                    │  Input Capture (→ server)            │
                    │  UI Overlay (HUD, menus)             │
                    │  State Applicator (delta → ECS)      │
                    │                                      │
                    │  Targets: Native (macOS/Win/Linux)   │
                    │           Browser (WebGPU + WASM)    │
                    └─────────────────────────────────────┘
```

### 3.2 Server Authority Model

The server is the single source of truth:

- **Server runs:** ECS, physics, game logic (Lua), AI agents, AI Director, event dispatch
- **Client runs:** Rendering, audio, input capture, UI overlay
- **Server streams:** State deltas (entity transforms, spawns, despawns, component updates) to clients at 10-30 Hz
- **Client sends:** Input events only (key presses, mouse movements) — never positions or game state

This gives:
- **Anti-cheat** by design (clients can't lie about state)
- **Consistent experience** for all viewers (everyone sees the same world)
- **External control** (Telegram/MCP commands work because the server just executes them)
- **Zero client-side game logic** (clients are pure renderers)

### 3.3 Four-Word World Names

Every world gets a human-memorable address: `black.squirrel.white.deer`

- 4 words from a curated dictionary of ~2,000 common English words
- 2,000^4 = **16 trillion** unique addresses
- Easy to remember, easy to share verbally, easy to type
- Maps to a world ID on the server — **DNS for virtual worlds**

Examples:
- `snake.3d.nokia.mark` — Snake Sweeper game
- `rain.forest.deep.blue` — Generative nature scene
- `titan.arena.fire.gold` — Combat demo

---

## 4. What Already Exists (v1.0 Foundation)

16 phases built and working. This is not a greenfield project — it's proven infrastructure.

| System | Status | Implementation |
|--------|--------|---------------|
| Window + Input | Done | winit 0.30, keyboard/mouse events |
| Scene Graph | Done | YAML scenes with entity/component definitions |
| ECS | Done | hecs with Transform, MeshRenderer, Camera, Light, etc. |
| Rendering | Done | wgpu deferred pipeline: Shadow → G-Buffer → Splat → Lighting → Bloom → Tonemap → FXAA → UI |
| Gaussian Splatting | Done | .ply loader, custom splat renderer integrated into deferred pipeline |
| PBR Materials | Done | YAML material definitions, Cook-Torrance GGX, metallic/roughness |
| Physics | Done | Rapier 3D: rigid bodies, colliders, joints, gravity |
| Scripting | Done | mlua (Lua 5.4): per-entity scripts, full API access |
| Audio | Done | Kira 0.9: music, SFX, fade-in/out, volume control, MP3/WAV |
| UI Overlay | Done | Immediate-mode 2D: text, rects, screen flash, bitmap font atlas |
| Entity Commands | Done | Runtime spawn/destroy/scale/visibility from Lua |
| MCP Server | Done | JSON-RPC over stdio, Claude can query/modify engine state |
| Telegram Bridge | Prototype | Bot receives commands, relays to engine via socket IPC |
| Event Bus | Done | Typed publish/subscribe for inter-system communication |
| Headless Mode | Done | `--headless` flag runs engine without window (for testing) |
| Shader Pipeline | Done | SLANG → WGSL compilation, YAML-defined render passes |

### Demo Scenes (16)

Every system has a working demo: PBR gallery (25 spheres), neon dreamscape, GENESIS (65 entities, 24 lights), TITAN (100+ entities, 32 lights), INFERNO (FPS arena), VOID (cosmic Gaussian splatting), UI showcase, Grid UI (Snake Sweeper prototype), Audio test.

---

## 5. Intelligence Layer (from v2.0)

### 5.1 Natural Language Compiler

The fastest path to world creation. A user describes what they want; the system generates the YAML + Lua files.

```
User:  "I want a 3D snake game on a neon grid with pulsing music"

NL Compiler:
  → scenes/snake.yaml        (scene graph: grid, snake, food, camera, lights)
  → logic/snake_controller.lua  (movement, growth, collision)
  → logic/food_spawner.lua      (random food placement)
  → materials/neon_grid.yaml    (emissive grid material)
```

**Implementation:** Claude API call with nAIVE format knowledge baked in. The MCP server already exists — the NL Compiler is an MCP tool that outputs files.

**Target:** >80% first-attempt correct scene generation.

### 5.2 LLM NPC Agents

Entities with `agent_brain` components become LLM-powered characters:

```yaml
- id: merchant
  components:
    transform:
      position: [5, 0, 3]
    mesh_renderer:
      mesh: assets/meshes/merchant.gltf
      material: assets/materials/merchant.yaml
    agent_brain:
      personality: "Gruff but fair dwarven blacksmith. Remembers repeat customers."
      memory_slots: 50
      inference_tier: 2    # 50ms distilled model
```

**Architecture:** Perception (what's nearby) → Memory (past interactions) → Reasoning (LLM call) → Action (Lua function calls).

**Tiered inference:**
| Tier | Latency | Use Case |
|------|---------|----------|
| 1 | 500ms | Complex conversation (Claude API) |
| 2 | 50ms | Routine dialogue (distilled local model) |
| 3 | 1ms | Cached responses (pattern match) |

### 5.3 AI Director

A background system that monitors player behavior and evolves the world:

```
Player telemetry → Analysis → Intervention plan → Graduated response

Intervention levels:
  Subtle:         Adjust spawn rates, lighting mood, music tempo
  Moderate:       Introduce new NPCs, modify terrain, create events
  Significant:    Restructure level layout, change game rules
  Transformative: Genre shifts, narrative pivots (requires player opt-in)
```

The Director runs on the server. Its interventions become state deltas that all clients receive.

### 5.4 Generative Gaussian Splatting (Gen-3DGS)

Text descriptions → 3D Gaussian splat assets. Bypasses the traditional photogrammetry pipeline.

```
"obsidian cavern with bioluminescent fungi"
  → CLIP encoding → Multi-view diffusion → 3DGS reconstruction → .ply asset
```

**Quality tiers:** Preview (~10K Gaussians, 2-5s) through Cinematic (~2M Gaussians, 5-15min).

### 5.5 Neural Render Passes

Portions of the render pipeline replaced with trainable neural networks:

```yaml
# render_pipeline.yaml extension
passes:
  - name: geometry_pass
    type: raster              # traditional SLANG
    shader: geometry.slang
  - name: style_transfer
    type: neural              # NEW: learned weights
    weights: ghibli_style.neural_shader
    inputs: [color_buffer, depth_buffer]
    output: styled_color
```

Style transfer, ambient occlusion estimation, denoising, super-resolution — learned from data instead of hand-coded.

---

## 6. Network Layer (v3.0 Core)

### 6.1 Headless Server Binary

`naive-server` — the same ECS + physics + scripting engine, compiled without wgpu:

```
naive-server
  ├── World Manager          (runs N worlds concurrently)
  ├── WebSocket Server       (accepts client connections)
  ├── Telegram Bridge        (receives NL commands)
  ├── World Registry         (four-word name → world ID)
  ├── Asset Store            (serves scene + asset files)
  ├── AI Agent Runtime       (LLM NPC inference)
  ├── AI Director            (per-world adaptive system)
  └── Per-World:
      ├── hecs World         (canonical ECS state)
      ├── Rapier Physics     (headless simulation)
      ├── mlua ScriptRuntime (Lua game logic)
      └── State Broadcaster  (delta compression + WebSocket send)
```

**Key implementation detail:** The existing `--headless` flag already runs without a window. The server binary is a feature-flagged build that excludes all of `src/renderer.rs`, `src/pipeline.rs`, `src/ui.rs`, `src/font.rs`, and wgpu dependencies.

### 6.2 Thin Client Binary

`naive-client` — rendering + input + audio, no game logic:

```
naive-client connect black.squirrel.white.deer
  ├── World Resolver         (4-word name → server address)
  ├── WebSocket Client       (receives state deltas)
  ├── Asset Cache            (downloads + caches scene assets)
  ├── State Applicator       (applies deltas to local ECS)
  ├── wgpu Renderer          (local GPU rendering)
  ├── Kira Audio             (local audio playback)
  ├── Input Capture          (keyboard/mouse → sends to server)
  └── UI Overlay             (HUD rendering from server-sent UI commands)
```

### 6.3 Connection Lifecycle

```
1. Client resolves four-word name → server address + world ID
2. WebSocket handshake with server
3. Server sends: full scene snapshot (YAML + asset manifest)
4. Client downloads assets it doesn't have (from CDN or server)
5. Client builds local ECS + renderer from scene definition
6. Server streams state deltas every tick (10-30 Hz)
7. Client applies deltas, renders locally, sends input events back
8. On disconnect: client state is discarded (server is truth)
```

### 6.4 State Delta Protocol

```json
{
  "tick": 1042,
  "updates": [
    {"entity": "snake_head", "transform": {"position": [3, 0, 5], "rotation": [0, 90, 0]}},
    {"entity": "snake_seg_4", "transform": {"position": [2, 0, 5]}},
    {"spawn": {
      "id": "food_7",
      "mesh": "procedural:sphere",
      "material": "assets/materials/food_gold.yaml",
      "position": [8, 0, 2],
      "scale": [0.3, 0.3, 0.3]
    }},
    {"despawn": "food_3"},
    {"component": {"entity": "player_1", "hidden": false}},
    {"ui": {"type": "text", "x": 10, "y": 10, "text": "Score: 450", "size": 24}},
    {"audio": {"type": "play_sfx", "id": "eat_7", "file": "assets/audio/eat.mp3", "vol": 0.8}}
  ]
}
```

Delta compression: only changed components are sent. Position deltas use quantized fixed-point for bandwidth efficiency.

### 6.5 Telegram Integration

The existing Telegram bot bridge (GENESIS demo prototype) is extended for v3:

```
User on Telegram:
  "make it rain in black.squirrel.white.deer"

Flow:
  1. Bot receives message
  2. AI parses intent → { action: "weather", params: { type: "rain" }, world: "black.squirrel.white.deer" }
  3. Bot sends command to server via internal API
  4. Server looks up world, executes in that world's Lua environment:
     weather.set("rain")  -- Lua function in the world's scripts
  5. Lua script:
     - Spawns particle emitter entity (rain drops)
     - Changes ambient light color (darker)
     - Plays rain audio loop
     - Modifies ground material (wet reflections)
  6. State deltas broadcast to all connected clients
  7. Everyone sees rain
  8. Bot replies: "It's raining in black.squirrel.white.deer"
```

**Commands can be anything the world's Lua scripts handle:**
- "spawn 10 red cubes" → `spawner.create("cube", {count=10, color="red"})`
- "change gravity to moon" → `physics.set_gravity(0, -1.62, 0)`
- "play jazz music" → `audio.play_music("assets/audio/jazz.wav", 0.5, 2.0)`
- "make the snake faster" → `snake.set_speed(2.0)`
- "add a forest" → NL Compiler generates trees, places them via entity.spawn()
- "reset the game" → `game.reset()`

### 6.6 Multiplayer

With server authority, multiplayer is inherent:

- Each connecting player gets a player entity spawned in the world
- Server runs game logic for all players simultaneously
- State deltas include all entities — all players see each other
- For Snake Sweeper: each player gets their own snake, server handles collision between snakes, shared minefield

**Player identity:**
- Anonymous by default (Telegram username or random guest ID)
- Four-word player names: `brave.fox.quick.nine`
- Permissions per world: owner, editor, player, viewer

### 6.7 World Registry

```
worlds/
  a1b2c3d4/                        # world ID (UUID)
    name: snake.3d.nokia.mark      # four-word address
    owner: mark                    # creator
    scene: scenes/snake.yaml       # scene definition
    logic/                         # Lua scripts
      snake_controller.lua
      food_spawner.lua
      mine_system.lua
    assets/                        # meshes, materials, audio
    state: <live ECS snapshot>     # current world state
    clients: [ws1, ws2, ws3]       # connected sessions
    config:
      max_players: 4
      tick_rate: 20                # Hz
      permissions: public
```

---

## 7. First World: Snake Sweeper

Snake Sweeper is the first real game published on nAIVE v3.0. It proves every system works end-to-end.

### 7.1 Why Snake Sweeper First

- **Already designed:** 729-line game design document covering every mechanic, visual effect, scoring system, and level structure
- **Already prototyped:** Grid UI demo (Phase 16) shows 49 runtime-spawned tiles, Minesweeper numbers, dynamic color, auto-walking snake
- **Audio proven:** testAssets MP3 files (eat, explosion, death, music) play correctly via Kira
- **Scope is right:** Complex enough to stress every system (ECS, physics, scripting, UI, audio, entity spawning), simple enough to build in weeks
- **Multiplayer natural fit:** Multiple snakes on the same minefield is immediately compelling
- **Telegram-controllable:** "add more mines", "change difficulty to hard", "reset level" are obvious commands

### 7.2 Snake Sweeper Network Architecture

```
Server (naive-server):
  - Runs 17x17 grid ECS with mine placement, food spawning, fog-of-war
  - Processes input events (WASD) from all connected players
  - Runs snake movement, collision detection, scoring per tick
  - AI Director can adjust mine density, food placement, speed based on player skill
  - Broadcasts state deltas: snake positions, tile reveals, score updates, audio triggers

Client (naive-client):
  - Renders 3D grid with PBR materials
  - Applies fog-of-war shader (tiles outside fog are dark)
  - Plays audio: heartbeat (proximity), eat, explosion, death, music
  - Renders UI: score, level, food icons, multiplier timer
  - Sends: arrow key presses only

Telegram:
  - "how's the game going?" → Bot queries server for score, level, snake length
  - "make it harder" → Server increases mine density and snake speed
  - "spawn a power-up" → Server places a shrink power-up near the snake
```

### 7.3 Core Mechanics (Summary)

- **Growth-as-punishment:** Hitting a mine grows the snake +3 segments (harder to control)
- **Shrink-as-reward:** Passing adjacent to a mine shrinks -1 segment
- **Proximity heartbeat:** Procedural audio intensifies near mines
- **Mine circumnavigation:** Visit all 8 tiles around a mine consecutively to defuse it (highest-skill move)
- **Number multipliers:** Minesweeper-style numbers grant 2x-4x score multipliers
- **Fog of war:** Limited vision radius, shrinks further after mine hit
- **10-level campaign + endless mode**

Full design: `docs/GAME_DESIGN_DOCUMENT.md`

---

## 8. Web Platform

### 8.1 Browser as Default Client

wgpu compiles to WebGPU via wasm-bindgen. The browser becomes the zero-install client:

```
User receives link: https://naive.world/black.squirrel.white.deer
  → Browser loads WASM client (~50MB)
  → WebSocket connects to server
  → Downloads scene assets
  → Renders locally via WebGPU
  → Plays audio via Web Audio API
  → Sends input via WebSocket
```

No download. No install. No app store. Share a link, play a game.

### 8.2 Platform Equivalence

| Feature | Native Client | Browser Client |
|---------|--------------|----------------|
| Rendering | wgpu (Vulkan/Metal/DX12) | WebGPU |
| Compute | Native GPU | WebGPU Compute Shaders |
| Audio | Kira | Web Audio API |
| Networking | WebSocket (tokio) | WebSocket (browser native) |
| Storage | Local filesystem | Origin Private File System |
| AI Inference | Local GPU + API | WebGPU + Server fallback |

### 8.3 Sharing and Discovery

- **Publish:** `naive publish snake.3d.nokia.mark` uploads world to server
- **Browse:** Web directory of public worlds (searchable, categorized)
- **Fork:** Clone any public world to remix it
- **Version control:** Rollback world state, branch for experiments
- **Permissions:** Public, private, invite-only (per four-word address)

---

## 9. Multi-Agent Collaborative Development

### 9.1 Agent Swarm

Multiple specialized AI agents collaborate to build, test, and evolve worlds:

| Agent | Role | Tools |
|-------|------|-------|
| Level Architect | Spatial layout, terrain, landmarks | NL Compiler, Gen-3DGS, Scene YAML |
| Narrative Director | Quests, dialogue, NPC personalities | Character YAML, Lua scripts |
| Systems Designer | Game mechanics, economy, balance | Component definitions, Lua |
| QA Tester | Plays autonomously, reports bugs | Full game API, telemetry |
| Art Director | Visual consistency, style transfer | Neural shaders, materials |
| Orchestrator | Coordinates agents, resolves conflicts | All APIs, project state |

### 9.2 Human-in-the-Loop

The agent swarm presents proposals. The human designer accepts, modifies, or rejects. The system learns preferences over time. The human remains the creative authority — AI amplifies, never overrides.

---

## 10. Implementation Roadmap

### 10.1 Immediate (Weeks 1-4): Snake Sweeper + Headless Server

**Goal:** Snake Sweeper playable locally as a complete game, plus headless server binary.

| Week | Deliverable |
|------|------------|
| 1 | Snake Sweeper core: grid, mines, food, fog, movement, collision, scoring |
| 2 | Snake Sweeper polish: effects (explosion, sparkle, shake), heartbeat audio, HUD, screens |
| 3 | Headless server binary (`naive-server`): feature-flagged build excluding renderer |
| 4 | WebSocket state streaming: server broadcasts deltas, test with two clients |

**Exit criteria:**
- Snake Sweeper runs as a complete 10-level game with all mechanics from the GDD
- `naive-server` runs Snake Sweeper world headlessly
- Two `naive-runtime` instances connect and see the same world state

### 10.2 Near-Term (Weeks 5-8): Thin Client + Four-Word Names

| Week | Deliverable |
|------|------------|
| 5 | Thin client binary (`naive-client`): connects via WebSocket, receives scene + deltas |
| 6 | Four-word world registry: name resolution, world storage, publishing |
| 7 | Multiplayer Snake Sweeper: 2-4 players, shared minefield, per-player snakes |
| 8 | Telegram bridge v2: AI-parsed commands to live worlds |

**Exit criteria:**
- `naive-client connect snake.3d.nokia.mark` opens a window showing the live game
- Two players play Snake Sweeper simultaneously on the same board
- Telegram message "make it harder" increases mine density in real-time

### 10.3 Medium-Term (Weeks 9-16): Intelligence Layer

| Week | Deliverable |
|------|------------|
| 9-10 | NL Compiler v1: text → YAML scene generation via Claude API |
| 11-12 | NPC Agent prototype: single LLM entity with memory and personality |
| 13-14 | AI Director v1: telemetry → adaptive difficulty for Snake Sweeper |
| 15-16 | WebGPU/WASM build target: browser client |

**Exit criteria:**
- "I want a 3D snake game" produces a playable scene on first attempt
- An NPC merchant in a demo world remembers previous conversations
- Snake Sweeper dynamically adjusts difficulty based on player performance
- Snake Sweeper plays in a browser via WebGPU

### 10.4 Long-Term (Weeks 17-32): Platform + Advanced AI

| Phase | Deliverable |
|-------|------------|
| 17-20 | Gen-3DGS pipeline: text → Gaussian splat assets |
| 21-24 | Neural shader prototype: learnable post-processing pass |
| 25-28 | Multi-agent collaboration: agent swarm builds worlds |
| 29-32 | Web platform: world browser, forking, permissions, CDN |

---

## 11. Technical Specifications

### 11.1 Server Requirements

- **CPU:** 2+ cores per world (ECS tick + Lua + physics)
- **Memory:** ~50MB per world (ECS + physics + script state)
- **Network:** ~10KB/s per client at 20 Hz tick rate (delta compressed)
- **Concurrency:** Tokio async runtime, one task per world, WebSocket per client
- **Scaling:** Single server handles ~100 worlds with 1-10 clients each on a modest VPS

### 11.2 Client Requirements

- **GPU:** Any wgpu-compatible GPU (Vulkan 1.0 / Metal / DX12 / WebGPU)
- **Memory:** ~200MB (renderer + asset cache)
- **Network:** ~10KB/s downstream (state deltas) + ~1KB/s upstream (input events)
- **Browser:** Chrome 113+ / Firefox 121+ / Safari 18+ (WebGPU support)

### 11.3 State Delta Bandwidth

| Scenario | Entities | Delta Size | At 20 Hz |
|----------|----------|-----------|----------|
| Snake Sweeper (1 player) | ~50 | ~500 bytes | ~10 KB/s |
| Snake Sweeper (4 players) | ~80 | ~800 bytes | ~16 KB/s |
| TITAN demo (100+ entities) | ~130 | ~2 KB | ~40 KB/s |
| GENESIS (65 entities) | ~65 | ~1 KB | ~20 KB/s |

Well within WebSocket capabilities. No need for UDP or custom transport.

### 11.4 Binary Architecture

```
Cargo.toml:
  [features]
  default = ["client"]
  client = ["wgpu", "winit", "kira"]   # rendering, window, audio
  server = ["tokio", "tungstenite"]     # async runtime, WebSocket

  [[bin]]
  name = "naive-runtime"     # current: full local engine
  required-features = ["client"]

  [[bin]]
  name = "naive-server"      # headless world server
  required-features = ["server"]

  [[bin]]
  name = "naive-client"      # thin rendering client
  required-features = ["client"]
```

Shared crate: `src/lib.rs` exports ECS, physics, scripting, scene loading, event bus. Binaries compose what they need.

---

## 12. The Telegram Experience

### 12.1 Bot Commands

```
/connect snake.3d.nokia.mark     — Monitor a world
/status                          — World stats (players, entities, tick rate)
/players                         — List connected players
/command <anything>              — Natural language command to the world

Examples:
  /command make it rain
  /command spawn 5 gold cubes at the center
  /command change the music to something spooky
  /command reset the game
  /command add a maze around the spawn point
  /command make the snake twice as fast
```

### 12.2 AI Command Parsing

```
Telegram message: "make it rain"

Claude API call:
  System: "You are a game command parser for a nAIVE world.
           Available Lua functions: weather.set(), spawner.create(),
           physics.set_gravity(), audio.play_music(), game.reset(), ..."
  User: "make it rain"
  Response: { "function": "weather.set", "args": ["rain"] }

Server executes: weather.set("rain") in the world's Lua environment
```

For simple/common commands, a local pattern matcher handles them without an API call (Tier 3 cached inference). Complex or creative commands go to Claude.

### 12.3 World Notifications

The bot can also push notifications:
```
"Player brave.fox.quick.nine just achieved a new high score of 12,450
 in snake.3d.nokia.mark! They survived to level 8."
```

---

## 13. Risk Assessment

| Risk | Severity | Mitigation | Fallback |
|------|----------|-----------|----------|
| WebSocket latency for gameplay | Medium | Server-side prediction, 20 Hz tick rate sufficient for Snake Sweeper's pace | Client-side input prediction for responsive feel |
| LLM API cost at scale | High | Tiered inference (Tier 3 cache, Tier 2 local, Tier 1 API) | Cache common responses, batch NPC updates |
| WebGPU browser adoption | Medium | WebGL2 fallback renderer (reduced features) | Native-first distribution, browser as bonus |
| Gen-3DGS quality insufficient | Medium | Progressive quality tiers, offline generation option | Curated asset library with style transfer |
| Server scaling costs | Medium | Lightweight worlds (~50MB each), horizontal scaling | Peer-to-peer mode for simple worlds |
| Telegram bot rate limits | Low | Queue commands, batch updates | Direct WebSocket API as alternative control channel |
| Neural shader perf on consumer GPU | High | FP16/INT8 quantization, resolution scaling | Traditional SLANG shaders as default, neural as opt-in |

---

## 14. Success Metrics

### 14.1 Technical

| Metric | Target | Measurement |
|--------|--------|-------------|
| Server tick rate | 20 Hz with 4 players | Tick time profiling |
| State delta latency | <100ms server-to-client | WebSocket round-trip measurement |
| Client frame rate | >60 FPS on M1 MacBook | Automated benchmark |
| WASM binary size | <50MB initial load | Build output measurement |
| NL Compiler accuracy | >80% first-attempt correct | Human evaluation of generated scenes |
| NPC response latency (Tier 1) | <500ms | P95 response time logging |
| Gen-3DGS preview generation | <5 seconds for 10K Gaussians | End-to-end pipeline timing |
| World startup time | <3 seconds from connect to first frame | Client-side timing |

### 14.2 Experience

- A non-programmer can create a playable game world in under 5 minutes using only natural language
- Snake Sweeper is playable by 4 concurrent players with no perceptible desync
- A Telegram message changes the live world within 1 second
- Sharing a four-word address is the only step needed for someone to join a world
- The browser client is indistinguishable from the native client for Snake Sweeper complexity levels

---

## 15. The nAIVE Promise

**For creators:** Describe what you imagine. AI builds it. Test it locally. Publish it with a four-word name. Anyone in the world can play it instantly.

**For players:** Hear about a game. Type four words. You're in. No download, no account, no app store. Your friend is already there. Someone on Telegram just made it rain.

**For AI:** You're not a tool — you're a collaborator, an inhabitant, a director. You live inside the world. You remember. You adapt. You create alongside humans in real-time.

This is nAIVE v3.0. Worlds created by AI. Shared with four words. Alive with intelligence.

---

## Appendix A: Existing Codebase Map

```
src/
  main.rs          — Entry point, module declarations
  engine.rs        — Core engine loop, system orchestration
  renderer.rs      — Forward renderer (legacy, unused in deferred mode)
  pipeline.rs      — Deferred render pipeline (Shadow → G-Buffer → Splat → Lighting → Bloom → Tonemap → FXAA)
  shader.rs        — SLANG → WGSL compilation, shader module cache
  world.rs         — Scene loading, ECS setup, entity lifecycle, EntityCommandQueue
  components.rs    — ECS components (Transform, MeshRenderer, Camera, Light, Hidden, etc.)
  scripting.rs     — Lua runtime, entity/physics/audio/ui API registration
  physics.rs       — Rapier 3D integration
  audio.rs         — Kira audio system (music, SFX, spatial)
  ui.rs            — Immediate-mode 2D overlay renderer
  font.rs          — Bitmap font atlas generator
  event_bus.rs     — Typed pub/sub event system
  mcp_server.rs    — MCP JSON-RPC server for Claude integration
  cli.rs           — Command-line argument parsing
  splat.rs         — Gaussian splatting renderer
  material.rs      — PBR material loading from YAML
  mesh.rs          — glTF mesh loading + procedural mesh generation

project/
  scenes/          — YAML scene definitions (16 demos)
  logic/           — Lua game scripts
  assets/          — Materials, meshes, shaders, splats
  shaders/         — SLANG shader source files

docs/
  nAIVE_Engine_PRD_v1.0.pdf    — Original engine specification
  nAIVE_Engine_PRD_v2.0.pdf    — AI runtime layer specification
  nAIVE_Engine_PRD_v3.0.md     — This document
  nAIVEv3.md                   — Networked worlds architecture notes
  GAME_DESIGN_DOCUMENT.md      — Snake Sweeper full game design
  SNAKE_SWEEPER_DEV_LOG.md     — Snake Sweeper development log
  architecture.html            — Interactive architecture diagram
  demos.html                   — Demo scene gallery and run commands
```

## Appendix B: Version History

| Version | Date | Focus |
|---------|------|-------|
| v1.0 | Jan-Feb 2026 | Core engine: 16 phases from window to UI overlay |
| v2.0 | Feb 2026 | AI runtime layer specification (LLM NPCs, NL compiler, Gen-3DGS, neural shaders) |
| v3.0 | Feb 2026 | Unified platform: networked worlds + AI intelligence + web distribution |

---

*"The most interesting games of the next decade will not be authored — they will be grown, evolved, inhabited, and co-created by humans and AI working together in shared persistent worlds."*

— End of Document —
