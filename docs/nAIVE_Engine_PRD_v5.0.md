# nAIVE Engine PRD v5.0 — The AI-Native Game Engine

**Version:** 5.0
**Date:** February 14, 2026
**Author:** Mark Ollila
**License:** MIT
**Status:** Draft
**Classification:** Public
**Companion Document:** nAIVE Platform PRD v5.0 (BSL 1.1)

---

## 1. Executive Summary

nAIVE is an open-source, AI-native game engine written in Rust. Worlds are created by AI, rendering happens on the client's GPU, and everything — scenes, materials, shaders, game logic — is a human-readable file that AI can generate, inspect, and modify.

v4.0 unified three layers (core engine, intelligence, networking) into a single platform specification. This document separates the **engine** from the **platform**, because they serve different audiences and carry different licenses:

- **This document (Engine PRD)** specifies everything a game developer needs to build and ship games with nAIVE. It covers rendering, physics, audio, scripting, GPU compute simulation, skeletal animation, character controllers, weapons, vehicles, and inventory. All MIT licensed. No restrictions.

- **The companion Platform PRD** specifies the server infrastructure: multiplayer hosting, world registry, matchmaking, AI Director, Telegram bridge, and the four-word addressing system. BSL 1.1 licensed.

You do not need the platform to ship a game. `naive-core` + `naive-client` + `naive-runtime` produce a complete single-player game binary. The platform adds multiplayer, hosting, and network services on top.

### What v5.0 Adds to the Engine

v4.0's engine was a renderer with scripting and physics. v5.0 adds the systems needed to build action games — shooters, brawlers, horde survival, racing — not just Snake Sweeper:

- **Gameplay primitives (DONE v0.1.2)** — health/damage, hitscan, projectiles, collision damage, third-person camera. Tier 1 complete.
- **Production foundations (DONE v0.1.4)** — dynamic GPU instance buffer (no more 256-entity ceiling), entity pooling, particle system, runtime entity queries, event subscription. Tier 2 complete.
- **Physics & scene API (DONE v0.1.7)** — physics impulse/velocity, collider materials, CCD, scene loading, camera shake, render debug HUD, 5 demo scenes. Tier 2.5 complete. Informed by Angry Birds dev log feedback.
- **GPU compute entity simulation** — 50,000+ physics-driven entities on the GPU. nAIVE's answer to Unreal's Niagara, but for gameplay entities, not just particles.
- **Vertex Animation Textures (VAT)** — baked skeletal animation sampled on the GPU for massive instanced rendering
- **Skeletal animation system** — glTF skinned meshes, animation state machines, blend trees
- **Character controller** — capsule-based movement with gravity, jumping, sprinting, crouching, third-person and first-person camera
- **Weapon system** — hitscan, projectile, and continuous weapons with YAML-defined stats
- **Vehicle system** — physics-driven vehicles with mounted weapons, mount/dismount
- **Inventory and loadout** — weapon slots, pickups, ammo, health/shield
- **Client-side prediction engine** — local player movement feels instant; reconciles with server when connected
- **Entity interpolation** — other entities rendered smoothly between network updates when connected

### Proof-of-Concept: HAVOC

HAVOC is a 3D Vampire Survivors-style horde survival game with vehicle combat. It can run as a single-player game using only MIT-licensed engine crates, or as 1-4 player co-op when combined with the platform.

A HAVOC prototype was already built in a single session during Tier 1 development. It validated the full gameplay loop (driving, killing, leveling, upgrading) but exposed hard engine limits: 256-entity ceiling, deferred destroy crashes, no VFX. The Tier 2 production foundations directly address every wall the prototype hit.

- **Health, hitscan, projectiles, collision damage** (Tier 1 — DONE)
- **Dynamic entity buffer + pooling + particles** (Tier 2 — removes the hard walls)
- **50,000+ GPU-simulated enemies** on screen simultaneously (Tier 3)
- **GPU neighbor-grid collisions** between horde entities (Tier 3)
- **Vertex Animation Textures** for GPU-instanced horde animation (Tier 4)
- **Third-person character controller** with skeletal animation (Tier 4)
- **Driveable vehicles** with collision damage (Tier 5)

If nAIVE can render 50,000 physics-driven goblins while you drive a truck through them — it can handle anything.

---

## 2. Vision

### 2.1 What Makes This Different

| Traditional Engine | nAIVE v5.0 |
|---|---|
| Games are compiled binaries | Worlds are YAML + Lua, generated by AI |
| Authoring requires programming | Describe what you want in natural language |
| Shaders are HLSL/GLSL platform-locked | SLANG shaders cross-compile to any GPU backend |
| 3D assets from art pipelines only | Gaussian splats generated from text prompts (Gen-3DGS) |
| Render pipeline hardcoded in C++ | YAML-defined render pipeline DAG — add passes without recompiling |
| Fixed visual style per game | Neural render passes swap visual styles at runtime |
| Entity counts limited by CPU | **GPU compute simulation drives 50,000+ entities at 60 FPS** |
| Particle systems are cosmetic | **GPU entity systems are gameplay — they collide, damage, path-find** |
| Animation requires full CPU skinning | **VAT animation scales to 50,000+ animated entities on GPU** |

### 2.2 The Promise

**For creators:** Describe what you imagine. AI builds it. Test it locally. Ship it. The engine is MIT — do anything you want with it. Sell your game. Never pay a royalty. Never give anything back. Or publish it with four words on the nAIVE platform and let anyone play it in a browser.

### 2.3 Design Philosophy

Six founding principles:

**The AI agent IS the editor.** nAIVE has no visual editor. The AI agent — Claude Code, or any MCP-capable LLM — is the editor. This thesis was validated at a Supercell AI Hackathon where a complete game was built using Claude Code as the sole development interface.

**Everything is a file.** Scenes, entities, materials, render pipelines, input bindings, event schemas — all human-readable YAML. No proprietary binary formats.

**Unix pipes connect everything.** AI services via standardized CLI pipes: Meshy for 3D geometry, ElevenLabs for voice, Flux for textures, Claude API for scene generation.

**SLANG shaders from day one.** NVIDIA's SLANG compiles to Metal, SPIR-V, WGSL, and CUDA. Supports auto-differentiation for neural rendering.

**Gaussian Splatting as first-class primitive.** Native renderable type alongside meshes, with hybrid depth compositing in the deferred pipeline.

**AI observability built in.** Frame streaming for AI vision, game state via command socket, structured event logging, simulated input for automated playtesting.

### 2.4 The Future of Rendering

```
1990s  Fixed-function pipeline     Hardwired vertex/pixel ops, no shaders
2000s  Programmable shaders        HLSL/GLSL — artists write lighting math
2010s  Physically-based rendering  Cook-Torrance, metallic/roughness, HDR
2020s  Neural rendering begins     NeRF, Gaussian splatting, differentiable rendering
2025+  AI-native rendering         Learned shaders, generated assets, prompted style
```

**Leap 1: Gaussian Splats Replace Polygons for AI-Generated Content.** Text prompt → Gen-3DGS → .ply file → scene entity. Seconds instead of days.

**Leap 2: Neural Shaders Replace Handcoded Shaders.** Visual style becomes data, not code — a weight file, downloadable, swappable, sharable.

```yaml
passes:
  - name: style_transfer
    type: neural
    weights: assets/neural/ghibli.weights
    inputs: [bloomed_color, depth]
    output: styled_color
```

**Leap 3: Prompt-to-Render.** A single sentence generates geometry (Gen-3DGS), lighting, particles, atmosphere, style (neural pass), and audio.

---

## 3. Core Technical Differentiators

### 3.1 SLANG as Shader Language

| Feature | SLANG | Raw WGSL/HLSL/GLSL |
|---------|-------|---------------------|
| Cross-compilation | Single source → WGSL, SPIR-V, HLSL, Metal, GLSL | Write per-platform |
| Module system | `import` with namespaces, interfaces, generics | Copy-paste or #include |
| Differentiable | Built-in auto-differentiation for neural shader training | Not possible |
| Type safety | Generics, interfaces, associated types | Weak typing |

All render passes are SLANG source files that cross-compile to WGSL at load time for wgpu.

### 3.2 Gaussian Splatting as First-Class Rendering Primitive

Splats flow through the same deferred pipeline as meshes. `.ply` files load with the same API as `.gltf` files.

```yaml
entities:
  - id: castle
    components:
      mesh_renderer:
        mesh: assets/meshes/castle.gltf
        material: assets/materials/stone.yaml

  - id: dragon
    components:
      splat_renderer:
        splat: assets/splats/crystal_dragon.ply
        scale: 2.0
```

### 3.3 Data-Driven YAML Render Pipeline

The render pipeline is a YAML-defined DAG of passes. Add, remove, or reorder render stages without recompiling. Neural passes slot alongside traditional passes.

```yaml
passes:
  - name: shadow_pass
    type: raster
    shader: passes/shadow.slang
    output: shadow_map

  - name: geometry_pass
    type: raster
    shader: passes/geometry.slang
    outputs: [albedo, normal, depth, metallic_roughness]

  - name: splat_pass
    type: compute
    shader: passes/splat_render.slang
    inputs: [depth]
    outputs: [albedo, normal]

  - name: lighting_pass
    type: raster
    shader: passes/deferred_light.slang
    inputs: [albedo, normal, depth, metallic_roughness, shadow_map]
    output: hdr_color

  - name: bloom_pass
    type: raster
    shader: passes/bloom.slang
    inputs: [hdr_color]
    output: bloomed_color

  - name: tonemap_pass
    type: raster
    shader: passes/tonemap.slang
    inputs: [bloomed_color]
    output: ldr_color

  - name: fxaa_pass
    type: raster
    shader: passes/fxaa.slang
    inputs: [ldr_color]
    output: final_color
```

### 3.4 AI as Runtime Primitive

AI is a runtime component, not external tooling:

| Traditional | nAIVE v5.0 |
|------------|-----------|
| AI writes code at dev time | AI runs inside the game at play time |
| NPCs follow pre-authored scripts | NPCs are LLM agents that reason, remember, adapt |
| 3D assets created by artists | 3D assets generated from text on demand |
| Visual style fixed at compile time | Neural render passes swap styles at runtime |
| Level design is manual | NL Compiler generates levels from natural language |

### 3.5 Self-Modifying Engine (Plugin Architecture)

Hot-loadable `.dylib/.so` modules with a versioned ABI boundary:

```rust
pub trait NaivePlugin: Send + Sync {
    fn name(&self) -> &str;
    fn version(&self) -> (u32, u32, u32);
    fn on_load(&mut self, ctx: &mut PluginContext);
    fn on_update(&mut self, ctx: &mut PluginContext, dt: f32);
    fn on_unload(&mut self, ctx: &mut PluginContext);
}
```

### 3.6 Extended MCP Server

14+ MCP tools covering scene management, NL compilation, agent interaction, asset generation, plugin management, and render pipeline modification. Makes Claude Code (or any MCP client) a first-class citizen.

| MCP Tool | Purpose |
|----------|---------|
| `naive/scene/load` | Load a scene YAML |
| `naive/scene/query` | Query entities, components, transforms |
| `naive/scene/modify` | Add/remove/update entities |
| `naive/nl/compile` | Natural language → YAML + Lua |
| `naive/generate/splat` | Text description → Gaussian splat (Gen-3DGS) |
| `naive/plugin/list` | List loaded plugins |
| `naive/plugin/swap` | Hot-swap a plugin at runtime |
| `naive/render/pipeline` | Query or modify the render pipeline YAML |

### 3.7 GPU Compute Entity Simulation (NEW in v5.0)

The most ambitious new system. nAIVE's answer to Unreal's Niagara.

Traditional game engines simulate entities on the CPU. At 10,000+ entities, the CPU becomes the bottleneck. nAIVE's GPU compute entity system simulates tens of thousands of physics-driven entities entirely on the GPU — flocking, collision, pathfinding, damage — all in compute shaders.

| Capability | CPU ECS | GPU Compute Entities (v5.0) |
|------------|---------|----------------------------|
| Max active entities | ~5,000 | **50,000+** |
| Collision detection | Rapier broadphase | **Neighbor-grid on GPU** |
| Pathfinding | A* on CPU | **Flow field on GPU** |
| Animation | Skeletal (CPU-skinned) | **VAT** (GPU-sampled) |
| Rendering | Individual draw calls | **GPU instancing** from compute buffer |
| Use case | Players, bosses, key NPCs | **Hordes, swarms, crowds, bullet hell** |

The two systems coexist. Players and bosses remain CPU ECS entities. Hordes and swarms use GPU compute entities. Full specification in Section 8.

---

## 4. Architecture

### 4.1 Crate Structure

nAIVE is split into three MIT-licensed crates:

```
┌─────────────────────────────────────────────────┐
│  naive-core (MIT)                                │
│  Shared types, ECS components, scene format,     │
│  serialization                                   │
└──────────────────────┬──────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────┐
│  naive-client (MIT)  [library crate]             │
│  Re-exports naive-core. Renderer, audio, input,  │
│  physics, scripting, UI, GPU horde sim, skeletal │
│  animation, prediction engine, interpolation —   │
│  all engine modules (25 total)                   │
└──────────────────────┬──────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────┐
│  naive-runtime (MIT)  [binary crate]             │
│  Thin CLI entry point. Produces `naive`,         │
│  `naive-runtime`, and `naive_mcp` binaries.      │
└─────────────────────────────────────────────────┘
```

**naive-core:** Shared types library. Contains ECS component definitions, scene format parsing, transform types, tween interpolation, event definitions, and all serialization logic. Re-exported by naive-client so downstream consumers get everything.

**naive-client:** Library crate containing the full engine. Re-exports naive-core. Contains the wgpu renderer, Kira audio, input capture, UI overlay, Rapier 3D physics, Lua scripting, GPU horde simulation shaders, skeletal animation, character controller, prediction engine, interpolation buffer, PBR materials, mesh loading, Gaussian splatting, CLI argument parsing, and command socket server. 25 modules total.

**naive-runtime:** Binary crate. A thin CLI entry point that depends on naive-client. Produces three binaries: `naive-runtime` (the main engine binary), `naive` (convenience alias), and `naive_mcp` (MCP JSON-RPC server for AI agent integration).

```toml
# crates/naive-runtime/Cargo.toml
[dependencies]
naive-client = { workspace = true }

[[bin]]
name = "naive-runtime"
path = "src/main.rs"

[[bin]]
name = "naive"
path = "src/main.rs"
```

**The server binary (`naive-server`) is specified in the companion Platform PRD.**

### 4.2 Rendering Philosophy: Client-Side Rendering

The engine renders locally on the client's GPU. If connected to a server, the server never touches a pixel — it sends state deltas, the client renders them.

```
Server-side rendering: 100 worlds × 10 players × $0.25/hr GPU = $180,000/month
Client-side rendering: 100 worlds on 2-core VPS = $25/month
Ratio: 9,000:1 cost advantage
```

This is what Minecraft, Roblox, Fortnite, and every successful multiplayer game uses.

### 4.3 Scene YAML as World Format

A "world" is a directory of files: YAML scenes, Lua scripts, YAML materials, glTF meshes, audio files, SLANG shaders, and VAT textures.

```
project/
  scenes/            — YAML scene definitions
  logic/             — Lua game scripts
  assets/
    materials/       — PBR material YAML files
    meshes/          — glTF 3D models (including skinned meshes)
    splats/          — Gaussian splatting .ply files
    vat/             — Vertex Animation Textures (.exr)
    audio/           — MP3/WAV/OGG audio files
  shaders/
    passes/          — SLANG render pass shaders
    compute/         — SLANG compute shaders (horde sim, etc.)
    modules/         — Shared SLANG modules
```

### 4.4 Data Flow (Single-Player / naive-runtime)

```
Player presses "W"
  → Input system captures key event
  → Character controller processes input: move forward 0.2m
  → Rapier physics: collision check, gravity, grounding
  → Lua script: game logic (stamina drain, footstep sound trigger)
  → GPU horde sim: compute shaders update 50,000 entities
  → ECS updated: player position, horde positions, animation states
  → Renderer: deferred pipeline draws frame
  → Audio: spatial sound, footstep SFX
  → Total frame time: <16ms at 60 FPS
```

### 4.5 Data Flow (Multiplayer / naive-client + Platform Server)

```
Player presses "W"
  → Client prediction: character controller moves player locally (instant)
  → Client sends input to server via WebRTC DataChannel
  → Server processes authoritatively, broadcasts delta to all clients
  → Client compares prediction to server state
    → Match (95%): discard prediction buffer
    → Mismatch (5%): rewind to server state, replay inputs
  → Other players: interpolated between last two server states
  → GPU horde sim: runs on client, parameterized by server-sent flow field
  → Perceived input latency: <16ms (one frame)
```

### 4.6 Client-Side Prediction Engine

Included in naive-client for use when connected to a server. Also usable in naive-runtime for consistent behavior.

**What is predicted:**
- Player position (character controller movement)
- Player rotation (camera/aim direction)

**What is NOT predicted:**
- Weapon fire (server-authoritative)
- Damage taken/dealt
- Inventory changes
- Horde entity positions (client-simulated independently)
- Other players (interpolated, not predicted)

**Reconciliation:** On receiving server state, compare predicted position to server position for the acknowledged tick. If diverged, rewind to server state and replay all unacknowledged inputs. This happens ~5% of frames (usually due to collisions with other players that the client couldn't predict).

### 4.7 Entity Interpolation

Other entities (players, NPCs, vehicles) are rendered by interpolating between the two most recent states received from the server:

```
Server sends position at tick 100: [43.0, 0, 87.0]
Server sends position at tick 101: [43.2, 0, 87.1]

Client renders at visual time = tick 100.5:
  position = lerp([43.0, 0, 87.0], [43.2, 0, 87.1], 0.5)
           = [43.1, 0, 87.05]
```

The client renders one tick behind the server (configurable). Extrapolation fallback if a packet is lost: linear extrapolation with exponential decay.

---

## 5. What Already Exists (v1.0 Foundation)

16 phases built and working:

| System | Status | Implementation |
|--------|--------|---------------|
| Window + Input | Done | winit 0.30, keyboard/mouse events |
| Scene Graph | Done | YAML scenes with entity/component definitions |
| ECS | Done | hecs with Transform, MeshRenderer, Camera, Light, Hidden, EntityId |
| Deferred Rendering | Done | 8-stage pipeline: Shadow → G-Buffer → Splat → Lighting → Bloom → Tonemap → FXAA → UI |
| Gaussian Splatting | Done | .ply loader, integrated into deferred pipeline |
| PBR Materials | Done | Cook-Torrance GGX, metallic/roughness/emissive |
| Shadow Mapping | Done | Directional shadow maps with PCF soft shadows |
| Post-Processing | Done | Bloom, tone mapping, FXAA |
| Physics | Done | Rapier 3D: rigid bodies, colliders, joints, gravity |
| Scripting | Done | mlua (Lua 5.4): per-entity scripts, full API |
| Audio | Done | Kira 0.9: music, SFX, fade-in/out, MP3/WAV/OGG |
| UI Overlay | Done | Immediate-mode 2D: text, rects, screen flash |
| Entity Commands | Done | Runtime spawn/destroy/scale/visibility from Lua |
| MCP Server | Done | JSON-RPC over stdio |
| Event Bus | Done | Typed publish/subscribe |
| Headless Mode | Done | `--headless` runs without window |
| Shader Pipeline | Done | SLANG → WGSL, YAML-defined render pipeline DAG |
| Procedural Meshes | Done | Sphere, cube, plane at runtime |

16 demo scenes exercising all systems. 20 features DONE.

### Tier 1 Gameplay Primitives (v0.1.2)

Implemented in v0.1.2. These are engine-level systems, not game-specific code:

| System | Status | Implementation |
|--------|--------|---------------|
| Health/Damage | Done | `Health` ECS component, `entity.damage()` / `entity.heal()` Lua API, `on_damage` / `on_death` callbacks |
| Hitscan API | Done | `physics.hitscan()` returns entity ID + hit point + normal, self-exclusion |
| Collision Damage | Done | `CollisionDamage` component, automatic damage on physics contact, owner-skip for projectiles |
| Projectile System | Done | `entity.spawn_projectile()` spawns physics-driven projectiles with velocity, gravity, lifetime, auto-damage via collision |
| Third-Person Camera | Done | `CameraMode::ThirdPerson` with configurable distance/height/pitch, wall collision via raycast |

---

## 6. Intelligence Layer (Engine-Side)

These AI capabilities run in the engine (client or runtime), not on the server.

### 6.1 Natural Language Compiler

Text descriptions → complete YAML + Lua files via MCP tool:

```
User:  "I want a 3D snake game on a neon grid with pulsing music"

NL Compiler:
  → scenes/snake.yaml
  → logic/snake_controller.lua
  → logic/food_spawner.lua
  → materials/neon_grid.yaml
  → materials/snake_body.yaml
```

Target: >80% first-attempt correct scene generation.

### 6.2 Generative Gaussian Splatting (Gen-3DGS)

Text descriptions → 3D Gaussian splat assets:

| Tier | Gaussians | Time | Quality |
|------|-----------|------|---------|
| Preview | ~10K | 2-5s | Draft |
| Standard | ~100K | 15-30s | Good |
| High | ~500K | 1-3min | Excellent |
| Cinematic | ~2M | 5-15min | Photorealistic |

### 6.3 Neural Render Passes

Portions of the render pipeline replaced with differentiable, trainable neural networks:

```yaml
passes:
  - name: style_transfer
    type: neural
    weights: ghibli_style.neural_shader
    inputs: [color_buffer, depth_buffer]
    output: styled_color
  - name: super_resolution
    type: neural
    weights: 2x_upscale.neural_shader
    inputs: [styled_color]
    output: final_color
```

Use cases: style transfer, ambient occlusion estimation, denoising, super-resolution. Performance target: >30 FPS on M1 MacBook with one neural pass active.

---

## 7. Skeletal Animation System (NEW in v5.0)

glTF skinned mesh support with animation state machines.

### 7.1 Pipeline

```
glTF file → Skeleton extraction (joints, bones, inverse bind matrices)
          → Animation clip loading (keyframes per joint per clip)
          → Runtime: Animation state machine drives blend weights
          → GPU skinning (vertex shader or compute shader)
```

### 7.2 Animation State Machine (YAML-Defined)

```yaml
animation_state_machine:
  states:
    idle:
      clip: animations/idle.gltf
      loop: true
      transitions:
        - to: run
          condition: speed > 0.5
        - to: jump
          condition: is_airborne
    run:
      clip: animations/run.gltf
      loop: true
      blend_parameter: speed
      transitions:
        - to: idle
          condition: speed < 0.1
        - to: jump
          condition: is_airborne
        - to: sprint
          condition: speed > 5.0
    jump:
      clip: animations/jump.gltf
      loop: false
      transitions:
        - to: fall
          condition: velocity_y < 0
    fall:
      clip: animations/fall.gltf
      loop: true
      transitions:
        - to: land
          condition: is_grounded
    land:
      clip: animations/land.gltf
      loop: false
      duration: 0.3
      transitions:
        - to: idle
          condition: animation_complete AND speed < 0.1
        - to: run
          condition: animation_complete AND speed > 0.5
```

**Animation blending:** Crossfade between states (configurable duration, default 0.15s). Upper body and lower body can play different animations simultaneously (layered animation).

---

## 8. GPU Compute Entity Simulation (NEW in v5.0)

The system that makes 50,000+ on-screen enemies possible. This runs entirely on the client GPU.

### 8.1 Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    GPU COMPUTE PIPELINE                   │
│                                                          │
│  ┌──────────┐   ┌──────────────┐   ┌────────────────┐  │
│  │ Spawn    │──>│ Simulation   │──>│ Animation      │  │
│  │ Buffer   │   │ Compute      │   │ (VAT sample)   │  │
│  │          │   │ Shader       │   │                │  │
│  └──────────┘   └──────┬───────┘   └───────┬────────┘  │
│                         │                    │           │
│                  ┌──────▼───────┐    ┌───────▼────────┐ │
│                  │ Neighbor     │    │ Instance       │ │
│                  │ Grid         │    │ Render Buffer  │ │
│                  │ (collision)  │    │ (transforms)   │ │
│                  └──────────────┘    └────────────────┘ │
│                                                          │
│  Inputs:                                                 │
│    - Flow field texture (128×128, for pathfinding)      │
│    - Spawn commands (position, count, type)              │
│    - Global parameters (max_speed, damage, etc.)         │
│                                                          │
│  Outputs:                                                │
│    - Per-instance transform buffer → GPU instanced draw  │
│    - Per-instance animation state (VAT time offset)      │
│    - Per-instance health (for damage flash shader)       │
│    - Player damage events (readback to CPU)              │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### 8.2 Compute Shader Pipeline

Each frame, the GPU runs a sequence of compute dispatches:

1. **Spawn** — New entities written into free slots. Atomic counter free-list tracks available slots.
2. **Flow Field Sample** — Each entity samples the flow field texture for desired velocity.
3. **Steering** — Separation, alignment, cohesion from neighbor grid. Combined with flow field.
4. **Neighbor Grid Build** — Entities binned into spatial grid via atomic scatter.
5. **Collision Resolution** — Iterate neighbors, apply separation forces, apply damage to player contact volumes.
6. **Integration** — Apply velocity to position. Clamp to world bounds. Update animation state.
7. **Death and Cleanup** — Health ≤ 0 → marked dead, slot returned to free list, death event buffered.
8. **Instance Buffer Write** — Living entities write transform + anim state to render buffer. Compaction removes gaps.

### 8.3 Vertex Animation Textures (VAT)

Skeletal animation doesn't scale to 50,000 entities. VAT bakes animation into textures:

**Baking (offline):**
```
glTF with skeletal animation
  → Sample vertex positions at each frame of each clip
  → Pack into texture: X = vertex index, Y = frame, RGBA = position offset + normal
  → Output: animation_atlas.exr (e.g., 1024 vertices × 150 frames × RGBA16F)
```

**Runtime (GPU, per-entity):**
```
vertex_position = base_mesh_position + texture_sample(vat_texture, vertex_id, anim_time)
```

**LOD levels:**

| Distance | Mesh | Animation | Draw |
|----------|------|-----------|------|
| < 30m | Full mesh (LOD0) | VAT sampling | GPU instanced |
| 30-80m | Simplified mesh (LOD1, 50% triangles) | VAT sampling | GPU instanced |
| 80m+ | Billboard sprite | Sprite sheet | Billboard batch |

### 8.4 YAML Configuration

```yaml
gpu_entity_system:
  name: goblin_horde
  max_entities: 65536
  mesh: assets/meshes/goblin_lod0.gltf
  mesh_lod1: assets/meshes/goblin_lod1.gltf
  mesh_lod2: billboard
  lod_distances: [30.0, 80.0]

  animation:
    type: vat
    texture: assets/vat/goblin_walk_run_die.exr
    clips:
      idle: { start: 0, end: 30 }
      walk: { start: 31, end: 60 }
      run: { start: 61, end: 90 }
      attack: { start: 91, end: 120 }
      die: { start: 121, end: 150 }

  simulation:
    compute_shader: shaders/horde_sim.slang
    collision: neighbor_grid
    grid_cell_size: 2.0
    pathfinding: flow_field
    flow_field_resolution: 128
    separation_radius: 1.0
    cohesion_radius: 5.0
    max_speed: 8.0
    health: 100
    damage_on_contact: 10

  spawning:
    wave_system: true
    initial_count: 1000
    spawn_rate: 200
    spawn_radius: 80.0
    max_alive: 50000
```

### 8.5 SLANG Compute Shader

```slang
struct HordeEntity {
    float3 position;
    float3 velocity;
    float health;
    float anim_time;
    uint type;          // 0 = melee, 1 = ranged, 2 = elite
    uint state;         // 0 = alive, 1 = dying, 2 = dead
};

RWStructuredBuffer<HordeEntity> entities;
Texture2D<float2> flow_field;
RWTexture2D<uint> neighbor_grid_counts;

[numthreads(256, 1, 1)]
void cs_simulate(uint3 tid : SV_DispatchThreadID) {
    uint idx = tid.x;
    if (idx >= alive_count) return;

    HordeEntity e = entities[idx];
    if (e.state != 0) return;

    // Sample flow field for pathfinding
    float2 grid_uv = e.position.xz / world_size;
    float2 desired_velocity = flow_field.SampleLevel(linear_sampler, grid_uv, 0);

    // Neighbor query for separation
    int2 cell = int2(e.position.xz / grid_cell_size);
    float3 separation = float3(0);
    // ... iterate neighbors, compute separation force

    // Combine steering forces
    float3 steering = float3(desired_velocity.x, 0, desired_velocity.y) * max_speed
                    + separation * separation_weight;

    // Integrate
    e.velocity = lerp(e.velocity, steering, dt * 5.0);
    e.position += e.velocity * dt;

    // Update animation based on speed
    float speed = length(e.velocity);
    e.anim_time += dt * speed * anim_speed_scale;

    entities[idx] = e;
}
```

---

## 9. Character Controller (NEW in v5.0)

Capsule collider-based movement using Rapier:

```yaml
character_controller:
  capsule:
    height: 1.8
    radius: 0.3
  movement:
    walk_speed: 5.0
    sprint_speed: 9.0
    crouch_speed: 2.5
    jump_force: 8.0
    gravity: -20.0
    air_control: 0.3
    ground_friction: 8.0
    air_friction: 0.5
  camera:
    mode: third_person       # or first_person
    distance: 4.0
    height_offset: 1.5
    collision: true
    spring_arm: true
    sensitivity: 2.0
    pitch_limits: [-60, 75]
```

**Touch input mapping (mobile):**
- Left virtual joystick: movement
- Right virtual joystick: camera/aim
- Jump button, fire button, weapon switch swipe

---

## 10. Weapon System (NEW in v5.0)

Weapons defined in YAML. In single-player (naive-runtime), hit detection runs locally. In multiplayer, hit detection is server-authoritative (see Platform PRD).

### 10.1 Weapon Types

```yaml
weapons:
  assault_rifle:
    type: hitscan
    fire_rate: 10.0
    damage: 22
    range: 100.0
    spread: 2.5
    recoil:
      vertical: 1.5
      horizontal: 0.3
      recovery: 5.0
    magazine: 30
    reload_time: 2.0
    headshot_multiplier: 2.0

  rocket_launcher:
    type: projectile
    fire_rate: 1.0
    damage: 120
    splash_radius: 5.0
    splash_falloff: linear
    projectile:
      speed: 40.0
      gravity: true
      lifetime: 5.0
      mesh: assets/meshes/rocket.gltf
      trail_effect: assets/effects/rocket_trail.yaml
    magazine: 1
    reload_time: 3.0

  flamethrower:
    type: continuous
    damage_per_second: 80
    range: 15.0
    cone_angle: 30.0
    fuel: 100
    fuel_drain: 20
    ignite_chance: 0.3
```

### 10.2 Hit Detection (Single-Player)

```
Player fires weapon
  → Raycast from player position in aim direction
  → Check intersection with ECS entities (Rapier colliders)
  → Apply damage to hit entity
  → Play hit effect at impact point
```

In multiplayer, the server performs the raycast and applies damage. The client plays cosmetic effects locally. See Platform PRD Section 7 for lag compensation and server-authoritative hit registration.

---

## 11. Vehicle System (NEW in v5.0)

Vehicles are Rapier rigid bodies:

```yaml
vehicles:
  war_buggy:
    type: wheeled
    physics:
      mass: 1500
      wheels: 4
      suspension_stiffness: 30.0
      max_speed: 25.0
      acceleration: 12.0
      brake_force: 20.0
      turn_rate: 2.5
    health: 500
    seats:
      driver:
        position: [0, 0.8, 0.3]
        controls: driving
      gunner:
        position: [0, 1.5, -0.5]
        controls: turret
        weapon: mounted_machine_gun
    mounted_machine_gun:
      type: hitscan
      fire_rate: 15.0
      damage: 15
      range: 80.0
      overheat: 5.0
      cooldown: 2.0
    mesh: assets/meshes/war_buggy.gltf
    enter_radius: 3.0

  truck:
    type: wheeled
    physics:
      mass: 5000
      wheels: 6
      max_speed: 18.0
      acceleration: 6.0
    health: 1200
    damage_on_collision: 80
    seats:
      driver:
        position: [0, 1.5, 1.0]
        controls: driving
    mesh: assets/meshes/truck.gltf
```

Press E near vehicle → mount. Press E while mounted → dismount. Vehicles damage horde enemies on collision.

---

## 12. Inventory and Loadout (NEW in v5.0)

```yaml
inventory:
  weapon_slots:
    primary: 1
    secondary: 1
    heavy: 1
    melee: 1          # always available

  consumable_slots: 4

  pickups:
    health_pack:
      heal: 50
      mesh: assets/meshes/health_pack.gltf
      respawn_time: 30.0
    shield_cell:
      shield: 25
      mesh: assets/meshes/shield_cell.gltf
      respawn_time: 20.0
    ammo_box:
      ammo: 60
      mesh: assets/meshes/ammo_box.gltf
      respawn_time: 15.0
```

---

## 13. Large World Support (NEW in v5.0)

### 13.1 Chunk-Based World Streaming

```yaml
world_streaming:
  chunk_size: 64.0
  load_radius: 3
  unload_radius: 5
```

Chunks are individual YAML scene files loaded/unloaded based on player position.

### 13.2 LOD System

- **Mesh LOD:** glTF meshes with multiple LOD levels, selected by screen-space size
- **Gaussian Splat LOD:** Progressive pruning — drop small/transparent Gaussians at distance
- **Horde LOD:** Full mesh → simplified mesh → billboard (Section 8.3)

### 13.3 Occlusion Culling

Frustum culling + optional Hi-Z occlusion culling for complex scenes.

---

## 14. Proof Game: HAVOC

HAVOC is a 3D Vampire Survivors-style horde survival game with vehicle combat. It runs as single-player on naive-runtime or as 1-4 player co-op when connected to the platform.

### 14.1 Why HAVOC

The game "There Are Millions of Goblins" (Unreal Engine 5, Niagara GPU simulation) demonstrated 50,000 physics-driven enemies with Vampire Survivors-style gameplay fused with vehicle combat. HAVOC proves nAIVE can match this:

| System | How HAVOC Proves It | Engine Tier |
|--------|-------------------|-------------|
| Health/damage/hitscan | Weapon damage, enemy death, collision damage | **Tier 1 (DONE)** |
| Projectiles | Physics-driven weapon projectiles | **Tier 1 (DONE)** |
| Dynamic buffer + pooling | 200+ CPU entities without crashes, horde pooling | **Tier 2 (DONE)** |
| Particle system | Kill effects, weapon VFX, boost trails | **Tier 2 (DONE)** |
| Event subscription | Cross-script game events (kills, waves, pickups) | **Tier 2 (DONE)** |
| Physics impulse + velocity | Knockback, explosion forces, launch mechanics | Tier 2.5 (DONE v0.1.7) |
| CCD + collider materials | Fast projectiles don't tunnel, surfaces bounce/slide correctly | Tier 2.5 (DONE v0.1.7) |
| GPU compute entities | 50,000+ goblins on GPU | Tier 3 |
| Neighbor-grid collisions | Goblins collide with each other and players | Tier 3 |
| VAT animation | 50,000 goblins animated via vertex textures | Tier 4 |
| Skeletal animation | Player character with full state machine | Tier 4 |
| Vehicles | War buggy, truck with collision damage | Tier 5 |

### 14.2 Game Design

**Concept:** Survive increasingly intense waves of goblin hordes. On foot or in vehicles.

**Setting:** Arena-scale map (~500m × 500m) with ruins, open fields, vehicle spawn points, elevation changes. Gothic-industrial aesthetic.

**Core Loop:**
```
Explore → Find weapons/vehicles → Survive wave → Brief respite → Harder wave → Repeat
  → Die → Score screen → Play again
```

**Wave progression:**

| Wave | Count | Types | Special |
|------|-------|-------|---------|
| 1-3 | 1K → 5K | Melee only | Tutorial, plentiful health drops |
| 4-6 | 5K → 15K | Melee + ranged | Ranged goblins, first vehicle |
| 7-9 | 15K → 30K | + elite | 3x health elites, rarer pickups |
| 10 | 30K → 50K | + boss | Goblin King (CPU ECS, full AI) |
| Endless | Scales | Dynamic | AI Director controls everything |

**Player abilities:** Sprint (stamina), dodge roll (i-frames), weapon swap, vehicle mount/dismount, AoE ground slam (cooldown, unlocked wave 3).

### 14.3 Performance Targets

| Metric | Target |
|--------|--------|
| Horde entities on screen | 50,000+ |
| Frame rate (desktop, RTX 3060) | 60 FPS |
| Frame rate (browser, WebGPU) | 30+ FPS |
| Frame rate (M1 MacBook) | 45+ FPS |

---

## 15. Platform Targets

| Platform | GPU Backend | Status |
|----------|-----------|--------|
| macOS (Intel + Apple Silicon) | Metal | DONE (primary dev) |
| Windows (x64) | Vulkan / DX12 | Supported |
| Linux (x64) | Vulkan | Supported |
| Browser (WebGPU + WASM) | WebGPU | Planned |
| Android (ARM64) | Vulkan | Planned |
| iOS (ARM64) | Metal | Planned |

---

## 16. Licensing

### MIT License

nAIVE engine (`naive-core`, `naive-client`, `naive-runtime`) is licensed under the MIT License.

```
MIT License

Copyright (c) 2026 Mark Ollila

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

**What this means:**

- Use nAIVE for any purpose — personal, commercial, educational
- Modify the source code however you want
- Sell games built with nAIVE — owe nothing, no royalties, no revenue share
- Fork nAIVE and build a competing engine — that's fine
- Include nAIVE in proprietary software — that's fine
- No CLA required for contributions

**The server (`naive-server`) is licensed separately under BSL 1.1.** See the companion Platform PRD for details. You do not need the server to build and ship games.

### Dependency Compatibility

| Dependency | License | Compatible |
|------------|---------|------------|
| wgpu | MIT/Apache-2.0 | Yes |
| hecs | MIT/Apache-2.0 | Yes |
| Rapier | Apache-2.0 | Yes |
| Kira | MIT/Apache-2.0 | Yes |
| mlua | MIT | Yes |
| serde | MIT/Apache-2.0 | Yes |
| shader-slang | MIT | Yes |

No GPL dependencies. All dependencies are MIT or Apache-2.0 compatible.

---

## 17. New ECS Components (v5.0)

All v4.0 components remain. v5.0 adds:

**Tier 1 — Implemented (v0.1.2)**

| Component | Purpose |
|-----------|---------|
| `health` | Health points with current/max, dead flag. Engine fires `on_damage`/`on_death` callbacks. |
| `collision_damage` | Auto-applies damage on physics contact. Configurable damage amount and destroy_on_hit. |
| `projectile` | Runtime-spawned physics projectile with damage, lifetime, owner tracking. |
| `camera_mode` | `FirstPerson` or `ThirdPerson { distance, height_offset, pitch_min, pitch_max }`. Wall collision via raycast. |
| `character_controller` | Capsule movement: walk, sprint, jump, step height |

**Tier 2 — Production Foundations** **DONE v0.1.4**

| Component | Purpose |
|-----------|---------|
| `particle_emitter` | Billboard particle source with rate, lifetime, velocity, color, size curves |
| `pool_member` | Marks entity as belonging to a named pool for acquire/release lifecycle |

**Tier 2.5 — Physics & Scene API (DONE v0.1.7)**

| Component / API | Purpose |
|-----------------|---------|
| `collider.restitution` | Bounciness of physics colliders (0.0–1.0). YAML: `collider: { restitution: 0.8 }` |
| `collider.friction` | Surface friction of physics colliders. YAML: `collider: { friction: 0.3 }` |
| `collider.ccd` | Continuous collision detection flag. Prevents fast-moving bodies (projectiles, slingshot ammo) from tunneling through thin surfaces. |

**Tier 3+ — Future**

| Component | Purpose |
|-----------|---------|
| `skeletal_mesh` | glTF skinned mesh with bone hierarchy |
| `animation_state` | Current clip, blend weight, state machine ref |
| `weapon_holder` | Equipped weapons, current weapon, ammo counts |
| `vehicle_seat` | Associates entity with a vehicle seat |
| `vehicle_physics` | Wheeled vehicle rigid body configuration |
| `horde_config` | GPU compute horde parameters for this world |
| `prediction_state` | Unacknowledged input buffer for reconciliation |
| `interpolation_buffer` | Last N server states for smooth rendering |
| `agent_brain` | LLM NPC personality, memory slots, inference tier (server runs inference; see Platform PRD Section 10) |

---

## 18. Implementation Roadmap

**Phase 1 (Weeks 1-4): Snake Sweeper + Headless Mode**

| Week | Deliverable |
|------|------------|
| 1 | Snake Sweeper core gameplay |
| 2 | Snake Sweeper polish: particles, heartbeat, HUD |
| 3 | Headless mode improvements for testing |
| 4 | State delta encoding/decoding in naive-core |

**Phase 1.5 (Informed by Snake Sweeper Devlog): Lua API Polish**

Snake Sweeper was built by Claude Code (Opus 4.6) in a single session using only `naive init` + CLAUDE.md as documentation. The devlog identified concrete API gaps that blocked or complicated the build. These are small, focused additions that improve the game development experience without architectural changes.

| API | Priority | Rationale |
|-----|----------|-----------|
| `entity.get_rotation(id) -> pitch, yaw, roll` | High | Complete the transform API. `set_rotation` exists but `get_rotation` doesn't. Any game with dynamic rotation needs manual tracking without this. |
| `entity.exists(id) -> bool` | High | No way to check if an entity is alive. `entity.destroy()` is deferred to end-of-frame, creating a race condition with `entity.spawn()` in the same frame. `exists()` enables defensive programming. |
| `entity.set_base_color(id, r, g, b)` | High | Only emission/roughness/metallic can be overridden at runtime. Base color requires pre-authored materials, limiting dynamic visual state changes. The devlog used emission-only tinting as a workaround, producing a glow-heavy aesthetic. |
| `camera.world_to_screen(x, y, z) -> sx, sy, visible` | High | Essential for any game that overlays UI on 3D entities (damage numbers, name tags, Minesweeper numbers). The devlog manually calculated screen projection from camera FOV — 5 lines of fragile math that breaks with camera movement. |
| `input.any_just_pressed() -> bool` | Medium | No "any key" query. Splash screens require checking every mapped action individually. |
| `ui.text_width(text, font_size) -> pixels` | Medium | No text measurement. Centering text requires magic numbers tuned by eye. |
| `entity.destroy_by_prefix(prefix)` | Medium | Bulk entity cleanup. Procedural games (grids, particles) track hundreds of entity IDs in arrays for cleanup. |
| `math.lerp(a, b, t) -> number` | Low | Used constantly for animations, fades, easing. Currently written inline everywhere. |

**Key Discovery: Deferred `entity.destroy()` Behavior**

`entity.destroy(id)` is queued and executed at end-of-frame. If `entity.spawn(id)` is called in the same frame after `entity.destroy(id)`, the spawn is a no-op (entity still exists), and the deferred destroy then removes it. This caused invisible entities and immediate deaths on level transitions. The safe pattern is: **never destroy entities you might re-use; hide them with `set_visible(false)` and reposition.** This must be documented in CLAUDE.md, the Game Development Guide, and engine docstrings.

**Phase 2 (Weeks 5-12): Intelligence Layer**

| Weeks | Deliverable |
|-------|------------|
| 5-6 | NL Compiler v1 via Claude API MCP tool |
| 7-8 | Gen-3DGS preview tier: text → Gaussian splat |
| 9-10 | Neural shader prototype: style transfer pass |
| 11-12 | WebGPU/WASM browser build |

**Phase 3: Engine Systems — Tiered by Game Capability**

The engine provides generic systems and Lua/YAML APIs. Game developers (human or AI) build content, logic, and game rules on top. HAVOC is a proof game built by a developer using these engine systems — it is not built into the engine.

**Tier 1 — Gameplay Primitives** (unblocks any action game) **DONE v0.1.2**

These systems let a game developer build a playable shooter/brawler/survival game at CPU entity scale. Implemented in engine version 0.1.2.

| System | Engine Provides | Game Dev Uses Via |
|--------|----------------|-------------------|
| Health/Damage components | Generic `Health` ECS component. Engine applies damage, tracks death state, fires `on_damage`/`on_death` callbacks. | Lua: `entity.get_health(id)`, `entity.damage(id, amount)`, `entity.heal(id, amount)`. YAML: `health: { max: 100 }` on entities. |
| Projectile system | Engine spawns physics-driven projectile entities with velocity, gravity, lifetime, auto-damage via `CollisionDamage`. | Lua: `entity.spawn_projectile(owner, mesh, material, pos, dir, speed, damage, lifetime, gravity)` |
| Third-person camera | Camera mode with configurable offset, collision-aware pullback via Rapier raycast. | YAML: `camera: { mode: third_person, distance: 4.0, height_offset: 1.5, pitch_limits: [-60, 75] }` |
| Hitscan API | Raycast from origin in direction, returns hit entity + point + normal. Self-exclusion built in. | Lua: `physics.hitscan(ox, oy, oz, dx, dy, dz, range)` returning `hit, entity_id, distance, hx, hy, hz, nx, ny, nz` |
| Collision damage | `CollisionDamage` component auto-applies damage on physics contact. Projectile owner-skip prevents self-damage. | YAML: `collision_damage: { damage: 25, destroy_on_hit: false }`. Engine handles detection automatically. |

**Tier 2 — Production Foundations** (makes nAIVE a shippable engine) **DONE v0.1.4**

Informed by the HAVOC dev log. A complete Vampire Survivors prototype was built in nAIVE in a single session, validating Tier 1 systems. But the developer hit hard walls — engine crashes from entity overflow, mandatory workarounds for deferred destroy, no VFX, no runtime queries. Tier 2 addressed every wall the prototype hit.

| System | Engine Provides | Game Dev Uses Via |
|--------|----------------|-------------------|
| Dynamic GPU instance buffer | Instance buffer grows automatically when entity count exceeds current capacity. No hard 256-entity ceiling. Graceful warning at configurable thresholds. | Transparent — game dev spawns entities freely. Engine handles buffer resizing. Target: 4K+ CPU entities before GPU becomes the bottleneck, not an arbitrary buffer. |
| Safe entity lifecycle | Deferred destroy processes before spawns within the same frame. Spawn+destroy in one frame no longer doubles buffer usage. Optional `entity.destroy_immediate()` for cases where the dev needs guaranteed slot reclamation. | Lua: existing `entity.destroy()` becomes safe by default. `entity.destroy_immediate(id)` for explicit control. |
| Built-in entity pooling | Engine-managed object pools. Pre-allocate N entities of a type, acquire/release without spawn/destroy overhead. Zero GPU buffer churn. | Lua: `entity.pool_create(name, count, mesh, material)`, `entity.pool_acquire(name)` returns id, `entity.pool_release(id)`. YAML: `pool: { name: "goblins", count: 200, mesh: ..., material: ... }` |
| Particle system | Lightweight 2D billboard particles with lifetime, velocity, gravity, color fade, size curve. GPU-instanced rendering from a dedicated particle buffer (separate from entity buffer). | Lua: `particles.emit(x, y, z, { count: 20, lifetime: 0.5, speed: 3.0, color: {1,1,0}, gravity: -5 })`. YAML: `particle_emitter: { rate: 50, lifetime: 1.0, ... }` on entities. |
| Runtime entity queries | Query entities by tag at runtime. Returns array of entity IDs matching a tag. | Lua: `scene.find_by_tag(tag)` returns `{id1, id2, ...}`. Eliminates hardcoded ID arrays in game scripts. |
| Event subscription | Lua scripts can subscribe to named events and receive callbacks. Completes the event bus (currently write-only from Lua). | Lua: `events.on("enemy_killed", function(data) ... end)`, `events.emit("enemy_killed", { id = eid, killer = pid })`. Cross-script communication without polling the `game` table. |

**Tier 2.5 — Physics & Scene API** (unblocks physics-driven games like Angry Birds) **DONE v0.1.7**

Informed by the Angry Birds dev log. A complete Angry Birds clone was built in nAIVE v0.1.2 in a single session. The game was playable but the developer hit critical API gaps: no way to apply impulses to rigid bodies (had to fake slingshot with set_position lerps), no velocity read/write (couldn't detect when birds stop moving), no scene transitions, no collider material properties (couldn't make surfaces bouncy or slippery), and fast projectiles tunneled through thin walls. These are fundamental physics engine APIs that any physics-driven game requires.

| System | Engine Provides | Game Dev Uses Via |
|--------|----------------|-------------------|
| Physics impulse API | Apply impulse/force to Rapier rigid bodies at runtime. Enables slingshots, explosions, knockback, wind. | Lua: `physics.apply_impulse(id, fx, fy, fz)`, `physics.apply_force(id, fx, fy, fz)` |
| Velocity read/write | Get and set linear velocity of rigid bodies. Essential for launch mechanics, movement detection, speed limits. | Lua: `physics.set_velocity(id, vx, vy, vz)`, `physics.get_velocity(id)` returns `vx, vy, vz` |
| Entity tag query | Read an entity's tag at runtime. Completes the tag API (tags are set in YAML but unreadable from Lua). | Lua: `entity.get_tag(id)` returns tag string or nil |
| Scene loading | Load/switch to a different scene at runtime. Enables level transitions, menus, game-over screens. | Lua: `scene.load("scenes/level2.yaml")` |
| Collider material properties | Restitution (bounciness) and friction per collider. YAML-configurable. | YAML: `collider: { shape: sphere, radius: 0.3, restitution: 0.8, friction: 0.3 }`. Lua: `physics.set_restitution(id, value)` |
| Continuous collision detection | CCD flag per rigid body. Prevents fast-moving objects (projectiles, slingshot ammo) from tunneling through thin geometry. | YAML: `rigid_body: { type: dynamic, ccd: true }`. Enabled automatically for projectiles. |
| Camera shake | Screen shake effect for impacts, explosions, destruction. | Lua: `camera.shake(intensity, duration)` with configurable decay |
| Render debug HUD | Interactive number-key toggles for render pass isolation (bloom, lights, emission, flicker, ambient). `--hud` CLI flag. | CLI: `naive run --hud`. Keys 0-6 toggle passes at runtime. Engine-level, works in all scenes. |

**Tier 3 — GPU Scale** (unblocks 50K entities)

These systems move entity simulation from CPU to GPU. Game developers configure behavior via YAML and SLANG compute shaders.

| System | Engine Provides | Game Dev Uses Via |
|--------|----------------|-------------------|
| GPU compute entity system | Generic compute pipeline: storage buffers for entity data, configurable dispatch, spawn/death slot management with atomic free-list. | YAML: `gpu_entity_system: { max_entities: 65536, compute_shader: shaders/compute/horde.slang }`. Game dev writes SLANG shader for entity behavior. |
| GPU neighbor grid | Spatial hash built on GPU each frame. Entities binned into cells. Query API for compute shaders. | Engine auto-builds grid from entity positions. Game dev's compute shader calls `query_neighbors(cell)` in SLANG. |
| GPU instanced rendering | Render 50K+ entities from compute-output transform buffer in one draw call per mesh type. | Automatic — engine reads instance buffer written by compute shader. Game dev configures mesh/material in YAML. |
| Flow field pathfinding | GPU wavefront propagation from target position. 2D grid of direction vectors. Entities sample field for steering. | YAML: `flow_field: { resolution: 128, cell_size: 4.0 }`. Engine recomputes when target moves. Game dev's compute shader samples `flow_field_texture`. |

**Tier 4 — Animation** (unblocks animated characters)

| System | Engine Provides | Game Dev Uses Via |
|--------|----------------|-------------------|
| Skeletal animation | glTF skinned mesh loading (joints, weights, inverse bind matrices). Animation clip parsing. State machine with crossfade blending. GPU skinning. | YAML: animation state machine definition (states, transitions, conditions). Lua: `entity.set_anim_state(id, "run")`, `entity.set_anim_param(id, "speed", 5.0)` |
| VAT loader + renderer | Load baked vertex animation textures (.exr). Vertex shader samples position/normal per frame. Works with GPU instanced rendering. | YAML: `animation: { type: vat, texture: assets/vat/goblin.exr, clips: { walk: { start: 0, end: 30 } } }` |

**Tier 5 — Vehicles** (unblocks vehicle combat)

| System | Engine Provides | Game Dev Uses Via |
|--------|----------------|-------------------|
| Vehicle physics | Rapier wheel joints, raycast suspension, engine torque, steering angle, brake force. | YAML: `vehicle: { wheels: 4, max_speed: 25.0, suspension_stiffness: 30.0 }` |
| Mount/dismount | Engine re-parents player to vehicle seat, switches input context (movement → driving). Proximity trigger. | Lua: `vehicle.mount(player_id, vehicle_id, "driver")`, `vehicle.dismount(player_id)`. Automatic on interact key near vehicle. |
| LOD system | Distance-based mesh switching. Billboard fallback at far distance. Engine selects LOD per frame. | YAML: `lod: { distances: [30, 80], meshes: [lod0.gltf, lod1.gltf], billboard: sprite.png }` |

**Implementation Schedule**

| Phase | Tier | Weeks | Deliverables |
|-------|------|-------|-------------|
| 3a | Tier 1: Gameplay Primitives | — | **DONE (v0.1.2)** Health/damage, projectiles, third-person camera, hitscan API, collision damage |
| 3b | Tier 2: Production Foundations | — | **DONE (v0.1.4)** Dynamic instance buffer, safe entity lifecycle, entity pooling, particle system, runtime queries, event subscription |
| 3b.5 | Tier 2.5: Physics & Scene API | — | **DONE (v0.1.7)** Physics impulse/velocity, entity.get_tag, scene.load, collider materials, CCD, camera shake, render debug HUD, 5 demo scenes |
| 3c | Tier 3: GPU Scale | 17-22 | GPU compute entity system, neighbor grid, instanced rendering, flow field |
| 3d | Tier 4: Animation | 23-26 | Skeletal animation + state machine, VAT loader + renderer |
| 3e | Tier 5: Vehicles | 27-30 | Vehicle physics, mount/dismount, LOD system |

**Phase 4: HAVOC — Proof Game (Built by Game Developer Using Engine)**

HAVOC is built entirely in YAML + Lua + SLANG using the engine systems from Phase 3. It validates that the engine APIs are sufficient for a AAA-scale horde survival game. No Rust code is written for HAVOC — if Rust is needed, that's a missing engine system.

A HAVOC prototype was already built during Tier 1 development using only CPU entities and Lua-side simulation. It validated the gameplay loop (driving, killing, leveling, upgrading) but hit hard limits: 256-entity ceiling, deferred destroy crashes, no VFX. Tier 2 (now complete) removed these walls. The full HAVOC rebuild on Tier 2.5+ will prove nAIVE is a production engine, not just a prototyping tool.

| Weeks | Deliverable | Engine Systems Exercised |
|-------|------------|------------------------|
| 31-32 | HAVOC core: arena scene, player controller, horde (pooled + particles) | Tier 1 (health, hitscan, third-person camera) + Tier 2 (pooling, particles, dynamic buffer, events) + Tier 2.5 (impulse, velocity, CCD) |
| 33-34 | HAVOC GPU horde: 50K goblin swarm, wave progression, 5 weapon types | Tier 3 (GPU entities, flow field) + Tier 4 (skeletal anim for player, VAT for horde) |
| 35-36 | HAVOC vehicles + polish: 2 vehicles, LOD, 10-wave campaign | Tier 5 (vehicles, mount/dismount, LOD) |

---

## 19. Technical Specifications

### 19.1 Client Requirements

| Component | Minimum | Recommended | HAVOC (50K horde) |
|-----------|---------|-------------|-------------------|
| GPU | Intel UHD 620 | Any dedicated GPU | RTX 3060+ |
| VRAM | 512 MB | 2 GB | 4 GB+ |
| RAM | 512 MB | 2 GB | 4 GB |
| Browser | Chrome 113+ | Latest stable | Latest + WebGPU |

### 19.2 Performance Targets

| Metric | Target |
|--------|--------|
| Frame rate (Snake Sweeper, M1 MacBook) | >60 FPS |
| Frame rate (HAVOC, desktop RTX 3060) | >60 FPS |
| Frame rate (HAVOC, browser WebGPU) | >30 FPS |
| Horde entity count (desktop) | 50,000+ |
| Horde entity count (browser) | 20,000+ |
| NL Compiler accuracy | >80% first-attempt correct |
| Neural shader FPS | >30 FPS on M1 with one pass |
| WASM binary size | <80 MB |

---

## 20. Risk Assessment

| Risk | Severity | Mitigation | Fallback |
|------|----------|-----------|----------|
| GPU compute portability | High | SLANG cross-compiles to WGSL, SPIR-V, Metal | CPU fallback with 5,000 entities |
| 50K entities on WebGPU | High | Aggressive LOD, billboard at distance | Cap browser at 20,000 |
| VAT texture memory | Medium | BC6H compression, 3-5 clips per type | Rotation-only animation |
| WebGPU browser support | Medium | WebGL2 fallback renderer | Native-first distribution |
| SLANG compilation speed | Low | Shader cache (compile once, reuse) | Pre-compiled WGSL fallback |
| Rapier scaling for vehicles | Low | Rapier handles hundreds of rigid bodies easily | Simplified vehicle physics |

---

## 21. Comparison to Existing Engines

| Feature | nAIVE v5.0 | Unity | Unreal | Godot |
|---------|-----------|-------|--------|-------|
| License | **MIT** | Subscription | Royalty | MIT |
| Language | Rust | C# | C++/Blueprints | GDScript/C# |
| World format | YAML + Lua | Proprietary | Proprietary | tscn (text) |
| AI-generatable | **Native** | Limited | No | Partial |
| Gaussian splatting | **Native** | Plugin | Plugin | No |
| GPU entity sim (50K+) | **Native** | VFX Graph | **Niagara** | No |
| Hot-reload | <200ms | 5-60s | 10-30s | 1-3s |
| MCP / AI control | **Native** | No | No | No |
| Neural shaders | **Native (SLANG)** | No | No | No |
| Browser target | WebGPU WASM | Limited | Pixel streaming | Planned |

---

## Appendix A: Existing Codebase Map

```
crates/
  naive-core/src/
    lib.rs, components.rs, scene.rs, transform.rs, tween.rs, events.rs
  naive-client/src/
    lib.rs             — Re-exports naive-core + declares all engine modules
    engine.rs          — Core engine loop
    pipeline.rs        — Deferred render pipeline
    shader.rs          — SLANG → WGSL compilation
    world.rs           — Scene loading, ECS setup
    scripting.rs       — Lua runtime
    physics.rs         — Rapier 3D
    audio.rs           — Kira 0.9
    ui.rs              — Immediate-mode 2D overlay
    font.rs            — Bitmap font atlas
    command.rs         — Command socket server
    cli.rs             — CLI arguments
    splat.rs           — Gaussian splatting renderer
    material.rs        — PBR materials from YAML
    mesh.rs            — glTF + procedural meshes
    ... (25 modules total)
  naive-runtime/src/
    main.rs            — Thin CLI entry point
    bin/naive_mcp.rs   — MCP JSON-RPC server
  naive-server/src/    — (see Platform PRD)
    lib.rs, main.rs
```

## Appendix B: HAVOC Weapon Stats

| Weapon | Type | Damage | Fire Rate | Range | Magazine | Reload |
|--------|------|--------|-----------|-------|----------|--------|
| Assault Rifle | Hitscan | 22 | 10/s | 100m | 30 | 2.0s |
| Shotgun | Hitscan (8 pellets) | 12×8 | 1.5/s | 20m | 6 | 2.5s |
| Rocket Launcher | Projectile | 120 (splash) | 1/s | ∞ | 1 | 3.0s |
| Flamethrower | Continuous | 80/s | — | 15m | 100 fuel | — |
| Sword | Melee | 60 | 2/s | 2m | ∞ | — |
| Mounted MG | Hitscan | 15 | 15/s | 80m | ∞ (overheat) | 2.0s cool |

## Appendix C: Glossary

| Term | Definition |
|------|-----------|
| **GPU compute entity** | Entity simulated on the GPU via compute shaders |
| **VAT** | Vertex Animation Texture — baked skeletal animation sampled on GPU |
| **Neighbor grid** | GPU-side spatial hash for entity-entity collision queries |
| **Flow field** | Precomputed pathfinding grid (each cell stores a direction vector) |
| **Horde** | Large group of GPU compute entities acting as a swarm |
| **SLANG** | NVIDIA shader language that cross-compiles to WGSL/SPIR-V/Metal/CUDA |
| **Gen-3DGS** | Generative Gaussian Splatting: text → 3D splat assets |
| **Neural pass** | Render pipeline stage implemented as a trained neural network |
| **LOD** | Level of Detail — reducing mesh complexity at distance |
| **Client-side prediction** | Client simulates local movement before server confirmation |
| **Entity interpolation** | Smoothly rendering entities between network state updates |
| **HAVOC** | nAIVE v5.0 proof game: horde survival with vehicle combat |
| **naive-core** | MIT library crate: shared types, ECS components, scene format, serialization |
| **naive-client** | MIT library crate: full engine — renderer, audio, input, physics, scripting, UI, all engine modules. Re-exports naive-core |
| **naive-runtime** | MIT binary crate: thin CLI entry point that uses naive-client. Produces `naive`, `naive-runtime`, and `naive_mcp` binaries |
